<!DOCTYPE html><html><head><meta charSet="utf-8"/><meta name="viewport" content="width=device-width"/><title>MyDocs</title><meta name="next-head-count" content="3"/><link rel="preload" href="/_next/static/css/a58c9bb1e05a64ba.css" as="style"/><link rel="stylesheet" href="/_next/static/css/a58c9bb1e05a64ba.css" data-n-g=""/><noscript data-n-css=""></noscript><script defer="" nomodule="" src="/_next/static/chunks/polyfills-c67a75d1b6f99dc8.js"></script><script src="/_next/static/chunks/webpack-d38be8d96a62f950.js" defer=""></script><script src="/_next/static/chunks/framework-2c79e2a64abdb08b.js" defer=""></script><script src="/_next/static/chunks/main-348c8faa34e64ab3.js" defer=""></script><script src="/_next/static/chunks/pages/_app-aef446c81fd4cad4.js" defer=""></script><script src="/_next/static/chunks/996-d065d3ec5d2a41d4.js" defer=""></script><script src="/_next/static/chunks/635-fe39bb0306c39624.js" defer=""></script><script src="/_next/static/chunks/pages/docs/%5Bid%5D-3de24ad21bbbcfc8.js" defer=""></script><script src="/_next/static/IGkoUEr--rzawFeP5CVO2/_buildManifest.js" defer=""></script><script src="/_next/static/IGkoUEr--rzawFeP5CVO2/_ssgManifest.js" defer=""></script></head><body><div id="__next"><div><a style="text-decoration:none" href="/"><div style="color:black;font-size:22px;cursor:pointer">MyDocs</div></a></div><p></p><h1><b># <!-- -->並行処理の考え方</b></h1><h2>競合状態</h2>
<p>データ処理に順番あり可能性がある。処理の間に 1 時間掛かっても問題ないか?と考える。</p>
<h2>アトミック性</h2>
<p>処理が行われたか、行われたかったかの 2 パターンしかない。処理を分解したときにこれ以上分解できない単位。
<code>i++</code> は非アトミック。</p>
<ul>
<li>i の値を取得する</li>
<li>i の値を 1 増やす</li>
<li>i の値を保存する</li>
</ul>
<p>アトミックな処理であれば複数のゴルーチンで安全に扱える。</p>
<h2>メモリアクセス同期</h2>
<p>排他処理が必要。 <code>sync.Mutex</code> で解決できる。</p>
<h2>デッドロック</h2>
<ul>
<li>相互排他<!-- -->
<ul>
<li>ある並行プロセスがリソースに対して排他的な権利をどの時点でも保持している</li>
</ul>
</li>
<li>条件待ち<!-- -->
<ul>
<li>ある並行プロセスがリソースの保持と追加のリソース街を同時に行う</li>
</ul>
</li>
<li>横取り不可<!-- -->
<ul>
<li>ある並行プロセスによって保持されているリソースはそのプロセスによってのみ開放される</li>
</ul>
</li>
<li>循環待ち<!-- -->
<ul>
<li>ある並行プロセス ( P1 ) は他の並行プロセス ( P2 ) を待たなければならない.そして P2 は P1 を待っている</li>
</ul>
</li>
</ul>
<h2>ライブロック</h2>
<p>ライブロックが起こる原因の多くは、試行回数に上限がない。 2 つの並行プロセスが互いのデッドロックを予防して起こる。</p>
<h2>リソース枯渇</h2>
<p>ライブロックのように 1 つ以上の貪欲なプロセスが他のリソースを奪うことで起こる。</p>
<pre><div class="sc-bcXHqe lmagiH"><div class="sc-gswNZR jJknjO">go</div><pre node="[object Object]" style="display:block;overflow-x:auto;padding:0.5em;background:#272822;color:#ddd"><code class="language-go" style="white-space:pre"><span style="color:#f92672;font-weight:bold">package</span><span> main
</span>
<span></span><span style="color:#f92672;font-weight:bold">import</span><span> (
</span><span>	</span><span style="color:#a6e22e">&quot;fmt&quot;</span><span>
</span><span>	</span><span style="color:#a6e22e">&quot;sync&quot;</span><span>
</span><span>	</span><span style="color:#a6e22e">&quot;time&quot;</span><span>
</span>)
<!-- -->
<span></span><span class="hljs-function" style="color:#f92672;font-weight:bold">func</span><span class="hljs-function"> </span><span class="hljs-function" style="color:#a6e22e;font-weight:bold">main</span><span class="hljs-function hljs-params">()</span><span> {
</span><span>	</span><span style="color:#f92672;font-weight:bold">var</span><span> wg sync.WaitGroup
</span><span>	</span><span style="color:#f92672;font-weight:bold">var</span><span> sharedLock sync.Mutex
</span><span>	</span><span style="color:#f92672;font-weight:bold">const</span><span> RUNTIME = </span><span class="hljs-number">1</span><span> * time.Second
</span>
<span>	greedWorker := </span><span class="hljs-function" style="color:#f92672;font-weight:bold">func</span><span class="hljs-function hljs-params">()</span><span> {
</span><span>		</span><span style="color:#f92672;font-weight:bold">defer</span><span> wg.Done()
</span>
<span>		</span><span style="color:#f92672;font-weight:bold">var</span><span> count </span><span style="color:#f92672;font-weight:bold">int</span><span>
</span><span>		</span><span style="color:#f92672;font-weight:bold">for</span><span> begin := time.Now(); time.Since(begin) &lt;= RUNTIME; {
</span>			sharedLock.Lock()
<span>			time.Sleep(</span><span class="hljs-number">3</span><span> * time.Nanosecond)
</span>			sharedLock.Unlock()
<!-- -->			count++
<!-- -->		}
<span>		fmt.Printf(</span><span style="color:#a6e22e">&quot;greed worker loops: %v\n&quot;</span><span>, count)
</span>	}
<!-- -->
<span>	politeWorker := </span><span class="hljs-function" style="color:#f92672;font-weight:bold">func</span><span class="hljs-function hljs-params">()</span><span> {
</span><span>		</span><span style="color:#f92672;font-weight:bold">defer</span><span> wg.Done()
</span>
<span>		</span><span style="color:#f92672;font-weight:bold">var</span><span> count </span><span style="color:#f92672;font-weight:bold">int</span><span>
</span><span>		</span><span style="color:#f92672;font-weight:bold">for</span><span> begin := time.Now(); time.Since(begin) &lt;= RUNTIME; {
</span>			sharedLock.Lock()
<span>			time.Sleep(</span><span class="hljs-number">1</span><span> * time.Nanosecond)
</span>			sharedLock.Unlock()
<!-- -->			sharedLock.Lock()
<span>			time.Sleep(</span><span class="hljs-number">1</span><span> * time.Nanosecond)
</span>			sharedLock.Unlock()
<!-- -->			sharedLock.Lock()
<span>			time.Sleep(</span><span class="hljs-number">1</span><span> * time.Nanosecond)
</span>			sharedLock.Unlock()
<!-- -->			count++
<!-- -->		}
<span>		fmt.Printf(</span><span style="color:#a6e22e">&quot;polite worker loops: %v\n&quot;</span><span>, count)
</span>	}
<!-- -->
<span>	wg.Add(</span><span class="hljs-number">2</span><span>)
</span><span>	</span><span style="color:#f92672;font-weight:bold">go</span><span> greedWorker()
</span><span>	</span><span style="color:#f92672;font-weight:bold">go</span><span> politeWorker()
</span>	wg.Wait()
<!-- -->}</code></pre></div></pre>
<pre><div class="sc-bcXHqe lmagiH"><div class="sc-gswNZR jJknjO">bash</div><pre node="[object Object]" style="display:block;overflow-x:auto;padding:0.5em;background:#272822;color:#ddd"><code class="language-shell" style="white-space:pre"><span style="color:#75715e">$</span><span class="bash"> go run main.go</span><span> 
</span>greed worker loops: 867215
<!-- -->polite worker loops: 524996</code></pre></div></pre></div><script id="__NEXT_DATA__" type="application/json">{"props":{"pageProps":{"contents":{"id":"20211104175819","title":"並行処理の考え方","body":"\n## 競合状態\nデータ処理に順番あり可能性がある。処理の間に 1 時間掛かっても問題ないか?と考える。\n\n## アトミック性\n処理が行われたか、行われたかったかの 2 パターンしかない。処理を分解したときにこれ以上分解できない単位。\n`i++` は非アトミック。\n- i の値を取得する\n- i の値を 1 増やす\n- i の値を保存する\n\nアトミックな処理であれば複数のゴルーチンで安全に扱える。\n\n## メモリアクセス同期\n排他処理が必要。 `sync.Mutex` で解決できる。\n\n## デッドロック\n- 相互排他\n  - ある並行プロセスがリソースに対して排他的な権利をどの時点でも保持している\n- 条件待ち\n  - ある並行プロセスがリソースの保持と追加のリソース街を同時に行う\n- 横取り不可\n  - ある並行プロセスによって保持されているリソースはそのプロセスによってのみ開放される\n- 循環待ち\n  - ある並行プロセス ( P1 ) は他の並行プロセス ( P2 ) を待たなければならない.そして P2 は P1 を待っている\n\n## ライブロック\nライブロックが起こる原因の多くは、試行回数に上限がない。 2 つの並行プロセスが互いのデッドロックを予防して起こる。\n\n## リソース枯渇\nライブロックのように 1 つ以上の貪欲なプロセスが他のリソースを奪うことで起こる。\n\n```go\npackage main\n\nimport (\n\t\"fmt\"\n\t\"sync\"\n\t\"time\"\n)\n\nfunc main() {\n\tvar wg sync.WaitGroup\n\tvar sharedLock sync.Mutex\n\tconst RUNTIME = 1 * time.Second\n\n\tgreedWorker := func() {\n\t\tdefer wg.Done()\n\n\t\tvar count int\n\t\tfor begin := time.Now(); time.Since(begin) \u003c= RUNTIME; {\n\t\t\tsharedLock.Lock()\n\t\t\ttime.Sleep(3 * time.Nanosecond)\n\t\t\tsharedLock.Unlock()\n\t\t\tcount++\n\t\t}\n\t\tfmt.Printf(\"greed worker loops: %v\\n\", count)\n\t}\n\n\tpoliteWorker := func() {\n\t\tdefer wg.Done()\n\n\t\tvar count int\n\t\tfor begin := time.Now(); time.Since(begin) \u003c= RUNTIME; {\n\t\t\tsharedLock.Lock()\n\t\t\ttime.Sleep(1 * time.Nanosecond)\n\t\t\tsharedLock.Unlock()\n\t\t\tsharedLock.Lock()\n\t\t\ttime.Sleep(1 * time.Nanosecond)\n\t\t\tsharedLock.Unlock()\n\t\t\tsharedLock.Lock()\n\t\t\ttime.Sleep(1 * time.Nanosecond)\n\t\t\tsharedLock.Unlock()\n\t\t\tcount++\n\t\t}\n\t\tfmt.Printf(\"polite worker loops: %v\\n\", count)\n\t}\n\n\twg.Add(2)\n\tgo greedWorker()\n\tgo politeWorker()\n\twg.Wait()\n}\n```\n\n```bash\n$ go run main.go \ngreed worker loops: 867215\npolite worker loops: 524996\n```\n"}},"__N_SSG":true},"page":"/docs/[id]","query":{"id":"20211104175819"},"buildId":"IGkoUEr--rzawFeP5CVO2","isFallback":false,"gsp":true,"scriptLoader":[]}</script></body></html>