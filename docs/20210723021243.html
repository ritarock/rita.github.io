<!DOCTYPE html><html><head><meta charSet="utf-8"/><meta name="viewport" content="width=device-width"/><title>MyDocs</title><meta name="next-head-count" content="3"/><link rel="preload" href="/_next/static/css/a58c9bb1e05a64ba.css" as="style"/><link rel="stylesheet" href="/_next/static/css/a58c9bb1e05a64ba.css" data-n-g=""/><noscript data-n-css=""></noscript><script defer="" nomodule="" src="/_next/static/chunks/polyfills-c67a75d1b6f99dc8.js"></script><script src="/_next/static/chunks/webpack-9b312e20a4e32339.js" defer=""></script><script src="/_next/static/chunks/framework-4556c45dd113b893.js" defer=""></script><script src="/_next/static/chunks/main-18053c3f67c4d467.js" defer=""></script><script src="/_next/static/chunks/pages/_app-867c56f07dfc6f09.js" defer=""></script><script src="/_next/static/chunks/10-be41e95a1b576b2e.js" defer=""></script><script src="/_next/static/chunks/668-6fd87f58c86db0c0.js" defer=""></script><script src="/_next/static/chunks/pages/docs/%5Bid%5D-eb53b8ffdeb3374a.js" defer=""></script><script src="/_next/static/rWqOYHmaiEb4Vzr7b2a11/_buildManifest.js" defer=""></script><script src="/_next/static/rWqOYHmaiEb4Vzr7b2a11/_ssgManifest.js" defer=""></script></head><body><div id="__next"><div><a class="sc-dkzDqf hPBBbq">MyDocs</a></div><p></p><h1><b># <!-- -->Golang の http/net について調べた</b></h1><h2>サーバ</h2>
<p>何もしないサーバを起動。</p>
<pre><div class="sc-bczRLJ xShwa"><div class="sc-gsnTZi iXcekV">go</div><pre node="[object Object]" style="display:block;overflow-x:auto;padding:0.5em;background:#272822;color:#ddd"><code class="language-go" style="white-space:pre"><span style="color:#f92672;font-weight:bold">package</span><span> main
</span>
<span></span><span style="color:#f92672;font-weight:bold">import</span><span> </span><span style="color:#a6e22e">&quot;net/http&quot;</span><span>
</span>
<span></span><span class="hljs-function" style="color:#f92672;font-weight:bold">func</span><span class="hljs-function"> </span><span class="hljs-function" style="color:#a6e22e;font-weight:bold">main</span><span class="hljs-function hljs-params">()</span><span> {
</span><span>	http.ListenAndServe(</span><span style="color:#a6e22e">&quot;&quot;</span><span>, </span><span style="color:#f92672;font-weight:bold">nil</span><span>)
</span>}</code></pre></div></pre>
<p><code>ListenAndServe</code> はネットワークアドレスとハンドラを引数で受け取る。ハンドラが nil の場合は <code>DefaultServerMux</code> が使われる。</p>
<p>Server の構造体はこんな感じ。</p>
<pre><div class="sc-bczRLJ xShwa"><div class="sc-gsnTZi iXcekV">go</div><pre node="[object Object]" style="display:block;overflow-x:auto;padding:0.5em;background:#272822;color:#ddd"><code class="language-go" style="white-space:pre"><span style="color:#f92672;font-weight:bold">type</span><span> Server </span><span style="color:#f92672;font-weight:bold">struct</span><span> {
</span><span>	Addr </span><span style="color:#f92672;font-weight:bold">string</span><span>
</span>	Handler Handler
<!-- -->	TLSConfig *tls.Config
<!-- -->	ReadTimeout time.Duration
<!-- -->	ReadHeaderTimeout time.Duration
<!-- -->	WriteTimeout time.Duration
<!-- -->	IdleTimeout time.Duration
<span>	MaxHeaderBytes </span><span style="color:#f92672;font-weight:bold">int</span><span>
</span><span>	TLSNextProto </span><span style="color:#f92672;font-weight:bold">map</span><span>[</span><span style="color:#f92672;font-weight:bold">string</span><span>]</span><span class="hljs-function" style="color:#f92672;font-weight:bold">func</span><span class="hljs-function hljs-params">(*Server, *tls.Conn, Handler)</span><span>
</span><span>	ConnState </span><span class="hljs-function" style="color:#f92672;font-weight:bold">func</span><span class="hljs-function hljs-params">(net.Conn, ConnState)</span><span>
</span>	ErrorLog *log.Logger
<span>	BaseContext </span><span class="hljs-function" style="color:#f92672;font-weight:bold">func</span><span class="hljs-function hljs-params">(net.Listener)</span><span class="hljs-function"> </span><span class="hljs-function" style="color:#a6e22e;font-weight:bold">context</span><span class="hljs-function">.</span><span class="hljs-function" style="color:#a6e22e;font-weight:bold">Context</span><span>
</span><span>	ConnContext </span><span class="hljs-function" style="color:#f92672;font-weight:bold">func</span><span class="hljs-function hljs-params">(ctx context.Context, c net.Conn)</span><span class="hljs-function"> </span><span class="hljs-function" style="color:#a6e22e;font-weight:bold">context</span><span class="hljs-function">.</span><span class="hljs-function" style="color:#a6e22e;font-weight:bold">Context</span><span>
</span>	inShutdown atomicBool
<span>	disableKeepAlives </span><span style="color:#f92672;font-weight:bold">int32</span><span>
</span>	nextProtoOnce     sync.Once
<!-- -->	nextProtoErr      error
<!-- -->	mu         sync.Mutex
<span>	listeners  </span><span style="color:#f92672;font-weight:bold">map</span><span>[*net.Listener]</span><span style="color:#f92672;font-weight:bold">struct</span><span>{}
</span><span>	activeConn </span><span style="color:#f92672;font-weight:bold">map</span><span>[*conn]</span><span style="color:#f92672;font-weight:bold">struct</span><span>{}
</span><span>	doneChan   </span><span style="color:#f92672;font-weight:bold">chan</span><span> </span><span style="color:#f92672;font-weight:bold">struct</span><span>{}
</span><span>	onShutdown []</span><span class="hljs-function" style="color:#f92672;font-weight:bold">func</span><span class="hljs-function hljs-params">()</span><span>
</span>}</code></pre></div></pre>
<p>設定を変更する場合は Server の構造体に値を指定する。</p>
<pre><div class="sc-bczRLJ xShwa"><div class="sc-gsnTZi iXcekV">go</div><pre node="[object Object]" style="display:block;overflow-x:auto;padding:0.5em;background:#272822;color:#ddd"><code class="language-go" style="white-space:pre"><span class="hljs-function" style="color:#f92672;font-weight:bold">func</span><span class="hljs-function"> </span><span class="hljs-function" style="color:#a6e22e;font-weight:bold">main</span><span class="hljs-function hljs-params">()</span><span> {
</span>	server := http.Server{
<span>		Addr:    </span><span style="color:#a6e22e">&quot;0.0.0.0:8080&quot;</span><span>,
</span><span>		Handler: </span><span style="color:#f92672;font-weight:bold">nil</span><span>,
</span>	}
<!-- -->	server.ListenAndServe()</code></pre></div></pre>
<h3>ハンドラとハンドラ関数</h3>
<p>ハンドラがない場合すべてのリクエストで 404 を返す。</p>
<p>ハンドラとは、 <code>ServerHTTP メソッド</code> を持ったインターフェースのことを指す。
このメソッドは、 <code>インターフェース HTTPResponseWriter</code> と <code>構造体 Request のポインタ</code> の 2 つの引数を取る。
つまり、 <code>ServerHTTP(http.ResponseWriter, *http.Request)</code> をもつインターフェースがハンドラになる。</p>
<pre><div class="sc-bczRLJ xShwa"><div class="sc-gsnTZi iXcekV">go</div><pre node="[object Object]" style="display:block;overflow-x:auto;padding:0.5em;background:#272822;color:#ddd"><code class="language-go" style="white-space:pre"><span style="color:#f92672;font-weight:bold">type</span><span> HelloHandler </span><span style="color:#f92672;font-weight:bold">struct</span><span>{}
</span>
<span></span><span class="hljs-function" style="color:#f92672;font-weight:bold">func</span><span class="hljs-function"> </span><span class="hljs-function hljs-params">(h *HelloHandler)</span><span class="hljs-function"> </span><span class="hljs-function" style="color:#a6e22e;font-weight:bold">ServeHTTP</span><span class="hljs-function hljs-params">(writer http.ResponseWriter, request *http.Request)</span><span> {
</span><span>	fmt.Fprintf(writer, </span><span style="color:#a6e22e">&quot;hello&quot;</span><span>)
</span>}
<!-- -->
<span></span><span class="hljs-function" style="color:#f92672;font-weight:bold">func</span><span class="hljs-function"> </span><span class="hljs-function" style="color:#a6e22e;font-weight:bold">main</span><span class="hljs-function hljs-params">()</span><span> {
</span><span>	helloHandler := </span><span style="color:#a6e22e">new</span><span>(HelloHandler)
</span>	server := http.Server{
<span>		Addr:    </span><span style="color:#a6e22e">&quot;0.0.0.0:8080&quot;</span><span>,
</span>		Handler: helloHandler,
<!-- -->	}
<!-- -->	server.ListenAndServe()
<!-- -->}</code></pre></div></pre>
<p>この状態だと、すべてのアクセスが 1 つのハンドラに行く。</p>
<p>実際は URL ごとに異なるハンドラで処理する必要があるため Handler フィールドに値を指定しない ( デフォルトで DefaultServerMux を使う ) 。</p>
<pre><div class="sc-bczRLJ xShwa"><div class="sc-gsnTZi iXcekV">go</div><pre node="[object Object]" style="display:block;overflow-x:auto;padding:0.5em;background:#272822;color:#ddd"><code class="language-go" style="white-space:pre"><span style="color:#f92672;font-weight:bold">type</span><span> HelloHandler </span><span style="color:#f92672;font-weight:bold">struct</span><span>{}
</span><span></span><span style="color:#f92672;font-weight:bold">type</span><span> WorldHandler </span><span style="color:#f92672;font-weight:bold">struct</span><span>{}
</span>
<span></span><span class="hljs-function" style="color:#f92672;font-weight:bold">func</span><span class="hljs-function"> </span><span class="hljs-function hljs-params">(h *HelloHandler)</span><span class="hljs-function"> </span><span class="hljs-function" style="color:#a6e22e;font-weight:bold">ServeHTTP</span><span class="hljs-function hljs-params">(writer http.ResponseWriter, request *http.Request)</span><span> {
</span><span>	fmt.Fprintf(writer, </span><span style="color:#a6e22e">&quot;hello&quot;</span><span>)
</span>}
<span></span><span class="hljs-function" style="color:#f92672;font-weight:bold">func</span><span class="hljs-function"> </span><span class="hljs-function hljs-params">(w *WorldHandler)</span><span class="hljs-function"> </span><span class="hljs-function" style="color:#a6e22e;font-weight:bold">ServeHTTP</span><span class="hljs-function hljs-params">(writer http.ResponseWriter, request *http.Request)</span><span> {
</span><span>	fmt.Fprintf(writer, </span><span style="color:#a6e22e">&quot;world&quot;</span><span>)
</span>}
<!-- -->
<span></span><span class="hljs-function" style="color:#f92672;font-weight:bold">func</span><span class="hljs-function"> </span><span class="hljs-function" style="color:#a6e22e;font-weight:bold">main</span><span class="hljs-function hljs-params">()</span><span> {
</span><span>	helloHandler := </span><span style="color:#a6e22e">new</span><span>(HelloHandler)
</span><span>	worldHandler := </span><span style="color:#a6e22e">new</span><span>(WorldHandler)
</span>	server := http.Server{
<span>		Addr: </span><span style="color:#a6e22e">&quot;0.0.0.0:8080&quot;</span><span>,
</span>	}
<span>	http.Handle(</span><span style="color:#a6e22e">&quot;/hello&quot;</span><span>, helloHandler)
</span><span>	http.Handle(</span><span style="color:#a6e22e">&quot;/world&quot;</span><span>, worldHandler)
</span>	server.ListenAndServe()
<!-- -->}</code></pre></div></pre>
<p><code>http.Handle</code> は実際には DefaultServeMux の Handle メソッドを呼び出している。</p>
<pre><div class="sc-bczRLJ xShwa"><div class="sc-gsnTZi iXcekV">go</div><pre node="[object Object]" style="display:block;overflow-x:auto;padding:0.5em;background:#272822;color:#ddd"><code class="language-go" style="white-space:pre"><span class="hljs-function" style="color:#f92672;font-weight:bold">func</span><span class="hljs-function"> </span><span class="hljs-function" style="color:#a6e22e;font-weight:bold">Handle</span><span class="hljs-function hljs-params">(pattern </span><span class="hljs-function hljs-params" style="color:#f92672;font-weight:bold">string</span><span class="hljs-function hljs-params">, handler Handler)</span><span> { DefaultServeMux.Handle(pattern, handler) }</span></code></pre></div></pre>
<p>ハンドラとは、 <code>ServerHTTP(http.ResponseWriter, *http.Request)</code> をもつインターフェースのこと。
ハンドラ関数とは、ハンドラのように振る舞う関数。リクエストのポインタを受け取ることができる。</p>
<pre><div class="sc-bczRLJ xShwa"><div class="sc-gsnTZi iXcekV">go</div><pre node="[object Object]" style="display:block;overflow-x:auto;padding:0.5em;background:#272822;color:#ddd"><code class="language-go" style="white-space:pre"><span style="color:#f92672;font-weight:bold">package</span><span> main
</span>
<span></span><span style="color:#f92672;font-weight:bold">import</span><span> (
</span><span>	</span><span style="color:#a6e22e">&quot;fmt&quot;</span><span>
</span><span>	</span><span style="color:#a6e22e">&quot;net/http&quot;</span><span>
</span>)
<!-- -->
<span></span><span style="color:#f92672;font-weight:bold">type</span><span> HelloHandler </span><span style="color:#f92672;font-weight:bold">struct</span><span>{}
</span><span></span><span style="color:#f92672;font-weight:bold">type</span><span> WorldHandler </span><span style="color:#f92672;font-weight:bold">struct</span><span>{}
</span>
<span></span><span class="hljs-function" style="color:#f92672;font-weight:bold">func</span><span class="hljs-function"> </span><span class="hljs-function hljs-params">(h *HelloHandler)</span><span class="hljs-function"> </span><span class="hljs-function" style="color:#a6e22e;font-weight:bold">ServeHTTP</span><span class="hljs-function hljs-params">(writer http.ResponseWriter, request *http.Request)</span><span> {
</span><span>	fmt.Fprintf(writer, </span><span style="color:#a6e22e">&quot;hello&quot;</span><span>)
</span>}
<span></span><span class="hljs-function" style="color:#f92672;font-weight:bold">func</span><span class="hljs-function"> </span><span class="hljs-function hljs-params">(w *WorldHandler)</span><span class="hljs-function"> </span><span class="hljs-function" style="color:#a6e22e;font-weight:bold">ServeHTTP</span><span class="hljs-function hljs-params">(writer http.ResponseWriter, request *http.Request)</span><span> {
</span><span>	fmt.Fprintf(writer, </span><span style="color:#a6e22e">&quot;world&quot;</span><span>)
</span>}
<!-- -->
<span></span><span class="hljs-function" style="color:#f92672;font-weight:bold">func</span><span class="hljs-function"> </span><span class="hljs-function" style="color:#a6e22e;font-weight:bold">hello</span><span class="hljs-function hljs-params">(writer http.ResponseWriter, request *http.Request)</span><span> {
</span><span>	fmt.Fprintf(writer, </span><span style="color:#a6e22e">&quot;hello&quot;</span><span>)
</span>}
<span></span><span class="hljs-function" style="color:#f92672;font-weight:bold">func</span><span class="hljs-function"> </span><span class="hljs-function" style="color:#a6e22e;font-weight:bold">world</span><span class="hljs-function hljs-params">(writer http.ResponseWriter, request *http.Request)</span><span> {
</span><span>	fmt.Fprintf(writer, </span><span style="color:#a6e22e">&quot;world&quot;</span><span>)
</span>}
<!-- -->
<span></span><span class="hljs-function" style="color:#f92672;font-weight:bold">func</span><span class="hljs-function"> </span><span class="hljs-function" style="color:#a6e22e;font-weight:bold">main</span><span class="hljs-function hljs-params">()</span><span> {
</span><span>	helloHandler := </span><span style="color:#a6e22e">new</span><span>(HelloHandler)
</span><span>	worldHandler := </span><span style="color:#a6e22e">new</span><span>(WorldHandler)
</span>	server := http.Server{
<span>		Addr: </span><span style="color:#a6e22e">&quot;0.0.0.0:8080&quot;</span><span>,
</span>	}
<span>	http.Handle(</span><span style="color:#a6e22e">&quot;/hello&quot;</span><span>, helloHandler)
</span><span>	http.Handle(</span><span style="color:#a6e22e">&quot;/world&quot;</span><span>, worldHandler)
</span><span>	http.HandleFunc(</span><span style="color:#a6e22e">&quot;/hello2&quot;</span><span>, hello)
</span><span>	http.HandleFunc(</span><span style="color:#a6e22e">&quot;/world2&quot;</span><span>, world)
</span>	server.ListenAndServe()
<!-- -->}</code></pre></div></pre>
<h3>何が違うのか</h3>
<p>やってることは <code>DefaultServeMux.Handle(pattern, handler)</code> なので同じ。
既存のインターフェースがある場合は、 <code>ServeHTTP</code> メソッドを追加するだけでハンドラになるからそういった場合は、 <code>http.Handle</code> のほうが手軽。</p>
<pre><div class="sc-bczRLJ xShwa"><div class="sc-gsnTZi iXcekV">go</div><pre node="[object Object]" style="display:block;overflow-x:auto;padding:0.5em;background:#272822;color:#ddd"><code class="language-go" style="white-space:pre"><span class="hljs-function" style="color:#f92672;font-weight:bold">func</span><span class="hljs-function"> </span><span class="hljs-function" style="color:#a6e22e;font-weight:bold">Handle</span><span class="hljs-function hljs-params">(pattern </span><span class="hljs-function hljs-params" style="color:#f92672;font-weight:bold">string</span><span class="hljs-function hljs-params">, handler Handler)</span><span> { DefaultServeMux.Handle(pattern, handler) }
</span>
<span></span><span class="hljs-function" style="color:#f92672;font-weight:bold">func</span><span class="hljs-function"> </span><span class="hljs-function" style="color:#a6e22e;font-weight:bold">HandleFunc</span><span class="hljs-function hljs-params">(pattern </span><span class="hljs-function hljs-params" style="color:#f92672;font-weight:bold">string</span><span class="hljs-function hljs-params">, handler </span><span class="hljs-function hljs-params" style="color:#f92672;font-weight:bold">func</span><span class="hljs-function hljs-params">(ResponseWriter, *Request)</span><span class="hljs-function">)</span><span> {
</span>	DefaultServeMux.HandleFunc(pattern, handler)
<!-- -->}
<!-- -->
<span></span><span class="hljs-function" style="color:#f92672;font-weight:bold">func</span><span class="hljs-function"> </span><span class="hljs-function hljs-params">(mux *ServeMux)</span><span class="hljs-function"> </span><span class="hljs-function" style="color:#a6e22e;font-weight:bold">HandleFunc</span><span class="hljs-function hljs-params">(pattern </span><span class="hljs-function hljs-params" style="color:#f92672;font-weight:bold">string</span><span class="hljs-function hljs-params">, handler </span><span class="hljs-function hljs-params" style="color:#f92672;font-weight:bold">func</span><span class="hljs-function hljs-params">(ResponseWriter, *Request)</span><span class="hljs-function">)</span><span> {
</span><span>	</span><span style="color:#f92672;font-weight:bold">if</span><span> handler == </span><span style="color:#f92672;font-weight:bold">nil</span><span> {
</span><span>		</span><span style="color:#a6e22e">panic</span><span>(</span><span style="color:#a6e22e">&quot;http: nil handler&quot;</span><span>)
</span>	}
<!-- -->	mux.Handle(pattern, HandlerFunc(handler))
<!-- -->}</code></pre></div></pre>
<h2>サードパーティー製のマルチプレクサ</h2>
<p>標準でも特に辛くない。 <code>request.Method</code> でメソッドも取得できるのでかなり使い勝手もいい。</p>
<pre><div class="sc-bczRLJ xShwa"><div class="sc-gsnTZi iXcekV">go</div><pre node="[object Object]" style="display:block;overflow-x:auto;padding:0.5em;background:#272822;color:#ddd"><code class="language-go" style="white-space:pre"><span>mux.HandleFunc(</span><span style="color:#a6e22e">&quot;/users/create&quot;</span><span>, createUsers)
</span><span>mux.HandleFunc(</span><span style="color:#a6e22e">&quot;/users/read/&quot;</span><span>, readUsers)
</span><span>mux.HandleFunc(</span><span style="color:#a6e22e">&quot;/users/update/&quot;</span><span>, updateUsers)
</span><span>mux.HandleFunc(</span><span style="color:#a6e22e">&quot;/users/delete/&quot;</span><span>, deleteUsers)
</span>
<span></span><span class="hljs-function" style="color:#f92672;font-weight:bold">func</span><span class="hljs-function"> </span><span class="hljs-function" style="color:#a6e22e;font-weight:bold">readerUsers</span><span class="hljs-function hljs-params">(writer http.ResponseWriter, request *http.Request)</span><span> {
</span><span>	sub := strings.TrimPrefix(request.URL.Path, </span><span style="color:#a6e22e">&quot;/users/read/&quot;</span><span>)
</span><span>	userId, err := strconv.Atoi(sub) </span><span style="color:#75715e">// これで /users/read/:id の id を取得できる</span><span>
</span>}</code></pre></div></pre>
<p>下記のような、 <code>/users/:user_id/tasks/:task_id</code> みたいに解析を結構頑張らないといけない場合は結構辛い。</p>
<pre><div class="sc-bczRLJ xShwa"><div class="sc-gsnTZi iXcekV">go</div><pre node="[object Object]" style="display:block;overflow-x:auto;padding:0.5em;background:#272822;color:#ddd"><code class="language-go" style="white-space:pre"><span>mux.HandleFunc(</span><span style="color:#a6e22e">&quot;/users/2/tasks/create&quot;</span><span>, createUsers)
</span><span>mux.HandleFunc(</span><span style="color:#a6e22e">&quot;/users/2/tasks/read/&quot;</span><span>, readUsers)
</span><span>mux.HandleFunc(</span><span style="color:#a6e22e">&quot;/users/2/tasks/update/&quot;</span><span>, updateUsers)
</span><span>mux.HandleFunc(</span><span style="color:#a6e22e">&quot;/users/2/tasks/delete/&quot;</span><span>, deleteUsers)</span></code></pre></div></pre>
<p>この辺が良さそう。</p>
<ul>
<li><a href="https://github.com/gorilla/mux">https://github.com/gorilla/mux</a></li>
<li><a href="https://github.com/julienschmidt/httprouter">https://github.com/julienschmidt/httprouter</a></li>
</ul></div><script id="__NEXT_DATA__" type="application/json">{"props":{"pageProps":{"contents":{"id":"20210723021243","title":"Golang の http/net について調べた","body":"\n## サーバ\n何もしないサーバを起動。\n```go\npackage main\n\nimport \"net/http\"\n\nfunc main() {\n\thttp.ListenAndServe(\"\", nil)\n}\n```\n\n`ListenAndServe` はネットワークアドレスとハンドラを引数で受け取る。ハンドラが nil の場合は `DefaultServerMux` が使われる。\n\nServer の構造体はこんな感じ。\n```go\ntype Server struct {\n\tAddr string\n\tHandler Handler\n\tTLSConfig *tls.Config\n\tReadTimeout time.Duration\n\tReadHeaderTimeout time.Duration\n\tWriteTimeout time.Duration\n\tIdleTimeout time.Duration\n\tMaxHeaderBytes int\n\tTLSNextProto map[string]func(*Server, *tls.Conn, Handler)\n\tConnState func(net.Conn, ConnState)\n\tErrorLog *log.Logger\n\tBaseContext func(net.Listener) context.Context\n\tConnContext func(ctx context.Context, c net.Conn) context.Context\n\tinShutdown atomicBool\n\tdisableKeepAlives int32\n\tnextProtoOnce     sync.Once\n\tnextProtoErr      error\n\tmu         sync.Mutex\n\tlisteners  map[*net.Listener]struct{}\n\tactiveConn map[*conn]struct{}\n\tdoneChan   chan struct{}\n\tonShutdown []func()\n}\n```\n\n設定を変更する場合は Server の構造体に値を指定する。\n```go\nfunc main() {\n\tserver := http.Server{\n\t\tAddr:    \"0.0.0.0:8080\",\n\t\tHandler: nil,\n\t}\n\tserver.ListenAndServe()\n```\n\n### ハンドラとハンドラ関数\nハンドラがない場合すべてのリクエストで 404 を返す。\n\nハンドラとは、 `ServerHTTP メソッド` を持ったインターフェースのことを指す。\nこのメソッドは、 `インターフェース HTTPResponseWriter` と `構造体 Request のポインタ` の 2 つの引数を取る。\nつまり、 `ServerHTTP(http.ResponseWriter, *http.Request)` をもつインターフェースがハンドラになる。\n```go\ntype HelloHandler struct{}\n\nfunc (h *HelloHandler) ServeHTTP(writer http.ResponseWriter, request *http.Request) {\n\tfmt.Fprintf(writer, \"hello\")\n}\n\nfunc main() {\n\thelloHandler := new(HelloHandler)\n\tserver := http.Server{\n\t\tAddr:    \"0.0.0.0:8080\",\n\t\tHandler: helloHandler,\n\t}\n\tserver.ListenAndServe()\n}\n```\n\nこの状態だと、すべてのアクセスが 1 つのハンドラに行く。\n\n実際は URL ごとに異なるハンドラで処理する必要があるため Handler フィールドに値を指定しない ( デフォルトで DefaultServerMux を使う ) 。\n\n```go\ntype HelloHandler struct{}\ntype WorldHandler struct{}\n\nfunc (h *HelloHandler) ServeHTTP(writer http.ResponseWriter, request *http.Request) {\n\tfmt.Fprintf(writer, \"hello\")\n}\nfunc (w *WorldHandler) ServeHTTP(writer http.ResponseWriter, request *http.Request) {\n\tfmt.Fprintf(writer, \"world\")\n}\n\nfunc main() {\n\thelloHandler := new(HelloHandler)\n\tworldHandler := new(WorldHandler)\n\tserver := http.Server{\n\t\tAddr: \"0.0.0.0:8080\",\n\t}\n\thttp.Handle(\"/hello\", helloHandler)\n\thttp.Handle(\"/world\", worldHandler)\n\tserver.ListenAndServe()\n}\n```\n\n`http.Handle` は実際には DefaultServeMux の Handle メソッドを呼び出している。\n\n```go\nfunc Handle(pattern string, handler Handler) { DefaultServeMux.Handle(pattern, handler) }\n```\n\nハンドラとは、 `ServerHTTP(http.ResponseWriter, *http.Request)` をもつインターフェースのこと。\nハンドラ関数とは、ハンドラのように振る舞う関数。リクエストのポインタを受け取ることができる。\n\n```go\npackage main\n\nimport (\n\t\"fmt\"\n\t\"net/http\"\n)\n\ntype HelloHandler struct{}\ntype WorldHandler struct{}\n\nfunc (h *HelloHandler) ServeHTTP(writer http.ResponseWriter, request *http.Request) {\n\tfmt.Fprintf(writer, \"hello\")\n}\nfunc (w *WorldHandler) ServeHTTP(writer http.ResponseWriter, request *http.Request) {\n\tfmt.Fprintf(writer, \"world\")\n}\n\nfunc hello(writer http.ResponseWriter, request *http.Request) {\n\tfmt.Fprintf(writer, \"hello\")\n}\nfunc world(writer http.ResponseWriter, request *http.Request) {\n\tfmt.Fprintf(writer, \"world\")\n}\n\nfunc main() {\n\thelloHandler := new(HelloHandler)\n\tworldHandler := new(WorldHandler)\n\tserver := http.Server{\n\t\tAddr: \"0.0.0.0:8080\",\n\t}\n\thttp.Handle(\"/hello\", helloHandler)\n\thttp.Handle(\"/world\", worldHandler)\n\thttp.HandleFunc(\"/hello2\", hello)\n\thttp.HandleFunc(\"/world2\", world)\n\tserver.ListenAndServe()\n}\n```\n\n### 何が違うのか\nやってることは `DefaultServeMux.Handle(pattern, handler)` なので同じ。\n既存のインターフェースがある場合は、 `ServeHTTP` メソッドを追加するだけでハンドラになるからそういった場合は、 `http.Handle` のほうが手軽。\n\n```go\nfunc Handle(pattern string, handler Handler) { DefaultServeMux.Handle(pattern, handler) }\n\nfunc HandleFunc(pattern string, handler func(ResponseWriter, *Request)) {\n\tDefaultServeMux.HandleFunc(pattern, handler)\n}\n\nfunc (mux *ServeMux) HandleFunc(pattern string, handler func(ResponseWriter, *Request)) {\n\tif handler == nil {\n\t\tpanic(\"http: nil handler\")\n\t}\n\tmux.Handle(pattern, HandlerFunc(handler))\n}\n```\n\n## サードパーティー製のマルチプレクサ\n標準でも特に辛くない。 `request.Method` でメソッドも取得できるのでかなり使い勝手もいい。\n```go\nmux.HandleFunc(\"/users/create\", createUsers)\nmux.HandleFunc(\"/users/read/\", readUsers)\nmux.HandleFunc(\"/users/update/\", updateUsers)\nmux.HandleFunc(\"/users/delete/\", deleteUsers)\n\nfunc readerUsers(writer http.ResponseWriter, request *http.Request) {\n\tsub := strings.TrimPrefix(request.URL.Path, \"/users/read/\")\n\tuserId, err := strconv.Atoi(sub) // これで /users/read/:id の id を取得できる\n}\n```\n\n下記のような、 `/users/:user_id/tasks/:task_id` みたいに解析を結構頑張らないといけない場合は結構辛い。\n```go\nmux.HandleFunc(\"/users/2/tasks/create\", createUsers)\nmux.HandleFunc(\"/users/2/tasks/read/\", readUsers)\nmux.HandleFunc(\"/users/2/tasks/update/\", updateUsers)\nmux.HandleFunc(\"/users/2/tasks/delete/\", deleteUsers)\n```\n\nこの辺が良さそう。\n- https://github.com/gorilla/mux\n- https://github.com/julienschmidt/httprouter\n"}},"__N_SSG":true},"page":"/docs/[id]","query":{"id":"20210723021243"},"buildId":"rWqOYHmaiEb4Vzr7b2a11","isFallback":false,"gsp":true,"scriptLoader":[]}</script></body></html>