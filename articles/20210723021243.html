<!DOCTYPE html><html><head><meta name="viewport" content="width=device-width"/><meta charSet="utf-8"/><title>MyDocs</title><meta name="next-head-count" content="3"/><link rel="preload" href="/_next/static/css/718387ccdbc2fd6d5285.css" as="style"/><link rel="stylesheet" href="/_next/static/css/718387ccdbc2fd6d5285.css" data-n-g=""/><noscript data-n-css=""></noscript><link rel="preload" href="/_next/static/chunks/webpack-189c53927ffd3caf09c3.js" as="script"/><link rel="preload" href="/_next/static/chunks/framework-2f612445bd50b211f15a.js" as="script"/><link rel="preload" href="/_next/static/chunks/main-c8b51cc0a92c3008cd1b.js" as="script"/><link rel="preload" href="/_next/static/chunks/pages/_app-7163558e7d92093a94d2.js" as="script"/><link rel="preload" href="/_next/static/chunks/996-109927db333074874af4.js" as="script"/><link rel="preload" href="/_next/static/chunks/394-1ac6c205f84cbd1b2925.js" as="script"/><link rel="preload" href="/_next/static/chunks/pages/articles/%5Bid%5D-ab036cc92d9ceaf2a9ff.js" as="script"/></head><body><div id="__next"><div><div><div class="bg-gray-600 h-10 leading-10 text-2xl"><a class="no-underline text-gray-100 mx-2" href="/">MyDocs</a></div></div><div class="mx-7"><h1><b># <!-- -->Golang の http/net について調べた</b></h1><h2>サーバ</h2>
<p>何もしないサーバを起動.</p>
<pre><div node="[object Object]" style="display:block;overflow-x:auto;padding:0.5em;background:#272822;color:#ddd"><code class="language-go" style="white-space:pre"><span style="color:#f92672;font-weight:bold">package</span><span> main
</span>
<span></span><span style="color:#f92672;font-weight:bold">import</span><span> </span><span style="color:#a6e22e">&quot;net/http&quot;</span><span>
</span>
<span></span><span class="hljs-function" style="color:#f92672;font-weight:bold">func</span><span class="hljs-function"> </span><span class="hljs-function" style="color:#a6e22e;font-weight:bold">main</span><span class="hljs-function hljs-params">()</span><span> {
</span><span>	http.ListenAndServe(</span><span style="color:#a6e22e">&quot;&quot;</span><span>, </span><span style="color:#f92672;font-weight:bold">nil</span><span>)
</span>}
</code></div></pre>
<p><code node="[object Object]">ListenAndServe</code> は ネットワークアドレスとハンドラを引数で受け取る.ハンドラが nil の場合は <code node="[object Object]">DefaultServerMux</code> が使われる.</p>
<p>Server の構造体はこんな感じ.</p>
<pre><div node="[object Object]" style="display:block;overflow-x:auto;padding:0.5em;background:#272822;color:#ddd"><code class="language-go" style="white-space:pre"><span style="color:#f92672;font-weight:bold">type</span><span> Server </span><span style="color:#f92672;font-weight:bold">struct</span><span> {
</span><span>	Addr </span><span style="color:#f92672;font-weight:bold">string</span><span>
</span>	Handler Handler
<!-- -->	TLSConfig *tls.Config
<!-- -->	ReadTimeout time.Duration
<!-- -->	ReadHeaderTimeout time.Duration
<!-- -->	WriteTimeout time.Duration
<!-- -->	IdleTimeout time.Duration
<span>	MaxHeaderBytes </span><span style="color:#f92672;font-weight:bold">int</span><span>
</span><span>	TLSNextProto </span><span style="color:#f92672;font-weight:bold">map</span><span>[</span><span style="color:#f92672;font-weight:bold">string</span><span>]</span><span class="hljs-function" style="color:#f92672;font-weight:bold">func</span><span class="hljs-function hljs-params">(*Server, *tls.Conn, Handler)</span><span>
</span><span>	ConnState </span><span class="hljs-function" style="color:#f92672;font-weight:bold">func</span><span class="hljs-function hljs-params">(net.Conn, ConnState)</span><span>
</span>	ErrorLog *log.Logger
<span>	BaseContext </span><span class="hljs-function" style="color:#f92672;font-weight:bold">func</span><span class="hljs-function hljs-params">(net.Listener)</span><span class="hljs-function"> </span><span class="hljs-function" style="color:#a6e22e;font-weight:bold">context</span><span class="hljs-function">.</span><span class="hljs-function" style="color:#a6e22e;font-weight:bold">Context</span><span>
</span><span>	ConnContext </span><span class="hljs-function" style="color:#f92672;font-weight:bold">func</span><span class="hljs-function hljs-params">(ctx context.Context, c net.Conn)</span><span class="hljs-function"> </span><span class="hljs-function" style="color:#a6e22e;font-weight:bold">context</span><span class="hljs-function">.</span><span class="hljs-function" style="color:#a6e22e;font-weight:bold">Context</span><span>
</span>	inShutdown atomicBool
<span>	disableKeepAlives </span><span style="color:#f92672;font-weight:bold">int32</span><span>
</span>	nextProtoOnce     sync.Once
<!-- -->	nextProtoErr      error
<!-- -->	mu         sync.Mutex
<span>	listeners  </span><span style="color:#f92672;font-weight:bold">map</span><span>[*net.Listener]</span><span style="color:#f92672;font-weight:bold">struct</span><span>{}
</span><span>	activeConn </span><span style="color:#f92672;font-weight:bold">map</span><span>[*conn]</span><span style="color:#f92672;font-weight:bold">struct</span><span>{}
</span><span>	doneChan   </span><span style="color:#f92672;font-weight:bold">chan</span><span> </span><span style="color:#f92672;font-weight:bold">struct</span><span>{}
</span><span>	onShutdown []</span><span class="hljs-function" style="color:#f92672;font-weight:bold">func</span><span class="hljs-function hljs-params">()</span><span>
</span>}
</code></div></pre>
<p>設定を変更する場合は Server の構造体に値を指定する.</p>
<pre><div node="[object Object]" style="display:block;overflow-x:auto;padding:0.5em;background:#272822;color:#ddd"><code class="language-go" style="white-space:pre"><span class="hljs-function" style="color:#f92672;font-weight:bold">func</span><span class="hljs-function"> </span><span class="hljs-function" style="color:#a6e22e;font-weight:bold">main</span><span class="hljs-function hljs-params">()</span><span> {
</span>	server := http.Server{
<span>		Addr:    </span><span style="color:#a6e22e">&quot;0.0.0.0:8080&quot;</span><span>,
</span><span>		Handler: </span><span style="color:#f92672;font-weight:bold">nil</span><span>,
</span>	}
<!-- -->	server.ListenAndServe()
</code></div></pre>
<h3>ハンドラとハンドラ関数</h3>
<p>ハンドラがない場合すべてのリクエストで 404 を返す.</p>
<p>ハンドラとは, <code node="[object Object]">ServerHTTP メソッド</code> を持ったインターフェースのことを指す.
このメソッドは, <code node="[object Object]">インターフェース HTTPResponseWriter</code> と <code node="[object Object]">構造体 Request のポインタ</code> の 2 つの引数を取る.
つまり, <code node="[object Object]">ServerHTTP(http.ResponseWriter, *http.Request)</code> をもつインターフェースがハンドラになる.</p>
<pre><div node="[object Object]" style="display:block;overflow-x:auto;padding:0.5em;background:#272822;color:#ddd"><code class="language-go" style="white-space:pre"><span style="color:#f92672;font-weight:bold">type</span><span> HelloHandler </span><span style="color:#f92672;font-weight:bold">struct</span><span>{}
</span>
<span></span><span class="hljs-function" style="color:#f92672;font-weight:bold">func</span><span class="hljs-function"> </span><span class="hljs-function hljs-params">(h *HelloHandler)</span><span class="hljs-function"> </span><span class="hljs-function" style="color:#a6e22e;font-weight:bold">ServeHTTP</span><span class="hljs-function hljs-params">(writer http.ResponseWriter, request *http.Request)</span><span> {
</span><span>	fmt.Fprintf(writer, </span><span style="color:#a6e22e">&quot;hello&quot;</span><span>)
</span>}
<!-- -->
<span></span><span class="hljs-function" style="color:#f92672;font-weight:bold">func</span><span class="hljs-function"> </span><span class="hljs-function" style="color:#a6e22e;font-weight:bold">main</span><span class="hljs-function hljs-params">()</span><span> {
</span><span>	helloHandler := </span><span style="color:#a6e22e">new</span><span>(HelloHandler)
</span>	server := http.Server{
<span>		Addr:    </span><span style="color:#a6e22e">&quot;0.0.0.0:8080&quot;</span><span>,
</span>		Handler: helloHandler,
<!-- -->	}
<!-- -->	server.ListenAndServe()
<!-- -->}
</code></div></pre>
<p>この状態だと,すべてのアクセスが 1 つのハンドラに行く.</p>
<p>実際は URL ごとに異なるハンドラで処理する必要があるため Handler フィールドに値を指定しない (デフォルトで DefaultServerMux を使う) .</p>
<pre><div node="[object Object]" style="display:block;overflow-x:auto;padding:0.5em;background:#272822;color:#ddd"><code class="language-go" style="white-space:pre"><span style="color:#f92672;font-weight:bold">type</span><span> HelloHandler </span><span style="color:#f92672;font-weight:bold">struct</span><span>{}
</span><span></span><span style="color:#f92672;font-weight:bold">type</span><span> WorldHandler </span><span style="color:#f92672;font-weight:bold">struct</span><span>{}
</span>
<span></span><span class="hljs-function" style="color:#f92672;font-weight:bold">func</span><span class="hljs-function"> </span><span class="hljs-function hljs-params">(h *HelloHandler)</span><span class="hljs-function"> </span><span class="hljs-function" style="color:#a6e22e;font-weight:bold">ServeHTTP</span><span class="hljs-function hljs-params">(writer http.ResponseWriter, request *http.Request)</span><span> {
</span><span>	fmt.Fprintf(writer, </span><span style="color:#a6e22e">&quot;hello&quot;</span><span>)
</span>}
<span></span><span class="hljs-function" style="color:#f92672;font-weight:bold">func</span><span class="hljs-function"> </span><span class="hljs-function hljs-params">(w *WorldHandler)</span><span class="hljs-function"> </span><span class="hljs-function" style="color:#a6e22e;font-weight:bold">ServeHTTP</span><span class="hljs-function hljs-params">(writer http.ResponseWriter, request *http.Request)</span><span> {
</span><span>	fmt.Fprintf(writer, </span><span style="color:#a6e22e">&quot;world&quot;</span><span>)
</span>}
<!-- -->
<span></span><span class="hljs-function" style="color:#f92672;font-weight:bold">func</span><span class="hljs-function"> </span><span class="hljs-function" style="color:#a6e22e;font-weight:bold">main</span><span class="hljs-function hljs-params">()</span><span> {
</span><span>	helloHandler := </span><span style="color:#a6e22e">new</span><span>(HelloHandler)
</span><span>	worldHandler := </span><span style="color:#a6e22e">new</span><span>(WorldHandler)
</span>	server := http.Server{
<span>		Addr: </span><span style="color:#a6e22e">&quot;0.0.0.0:8080&quot;</span><span>,
</span>	}
<span>	http.Handle(</span><span style="color:#a6e22e">&quot;/hello&quot;</span><span>, helloHandler)
</span><span>	http.Handle(</span><span style="color:#a6e22e">&quot;/world&quot;</span><span>, worldHandler)
</span>	server.ListenAndServe()
<!-- -->}
</code></div></pre>
<p><code node="[object Object]">http.Handle</code> は実際には DefaultServeMux の Handle メソッドを呼び出している.</p>
<pre><div node="[object Object]" style="display:block;overflow-x:auto;padding:0.5em;background:#272822;color:#ddd"><code class="language-go" style="white-space:pre"><span class="hljs-function" style="color:#f92672;font-weight:bold">func</span><span class="hljs-function"> </span><span class="hljs-function" style="color:#a6e22e;font-weight:bold">Handle</span><span class="hljs-function hljs-params">(pattern </span><span class="hljs-function hljs-params" style="color:#f92672;font-weight:bold">string</span><span class="hljs-function hljs-params">, handler Handler)</span><span> { DefaultServeMux.Handle(pattern, handler) }</span></code></div></pre>
<p>ハンドラとは, <code node="[object Object]">ServerHTTP(http.ResponseWriter, *http.Request)</code> をもつインターフェース のこと.
ハンドラ関数とは,ハンドラのように振る舞う関数.リクエストのポインタを受け取ることができる.</p>
<pre><div node="[object Object]" style="display:block;overflow-x:auto;padding:0.5em;background:#272822;color:#ddd"><code class="language-go" style="white-space:pre"><span style="color:#f92672;font-weight:bold">package</span><span> main
</span>
<span></span><span style="color:#f92672;font-weight:bold">import</span><span> (
</span><span>	</span><span style="color:#a6e22e">&quot;fmt&quot;</span><span>
</span><span>	</span><span style="color:#a6e22e">&quot;net/http&quot;</span><span>
</span>)
<!-- -->
<span></span><span style="color:#f92672;font-weight:bold">type</span><span> HelloHandler </span><span style="color:#f92672;font-weight:bold">struct</span><span>{}
</span><span></span><span style="color:#f92672;font-weight:bold">type</span><span> WorldHandler </span><span style="color:#f92672;font-weight:bold">struct</span><span>{}
</span>
<span></span><span class="hljs-function" style="color:#f92672;font-weight:bold">func</span><span class="hljs-function"> </span><span class="hljs-function hljs-params">(h *HelloHandler)</span><span class="hljs-function"> </span><span class="hljs-function" style="color:#a6e22e;font-weight:bold">ServeHTTP</span><span class="hljs-function hljs-params">(writer http.ResponseWriter, request *http.Request)</span><span> {
</span><span>	fmt.Fprintf(writer, </span><span style="color:#a6e22e">&quot;hello&quot;</span><span>)
</span>}
<span></span><span class="hljs-function" style="color:#f92672;font-weight:bold">func</span><span class="hljs-function"> </span><span class="hljs-function hljs-params">(w *WorldHandler)</span><span class="hljs-function"> </span><span class="hljs-function" style="color:#a6e22e;font-weight:bold">ServeHTTP</span><span class="hljs-function hljs-params">(writer http.ResponseWriter, request *http.Request)</span><span> {
</span><span>	fmt.Fprintf(writer, </span><span style="color:#a6e22e">&quot;world&quot;</span><span>)
</span>}
<!-- -->
<span></span><span class="hljs-function" style="color:#f92672;font-weight:bold">func</span><span class="hljs-function"> </span><span class="hljs-function" style="color:#a6e22e;font-weight:bold">hello</span><span class="hljs-function hljs-params">(writer http.ResponseWriter, request *http.Request)</span><span> {
</span><span>	fmt.Fprintf(writer, </span><span style="color:#a6e22e">&quot;hello&quot;</span><span>)
</span>}
<span></span><span class="hljs-function" style="color:#f92672;font-weight:bold">func</span><span class="hljs-function"> </span><span class="hljs-function" style="color:#a6e22e;font-weight:bold">world</span><span class="hljs-function hljs-params">(writer http.ResponseWriter, request *http.Request)</span><span> {
</span><span>	fmt.Fprintf(writer, </span><span style="color:#a6e22e">&quot;world&quot;</span><span>)
</span>}
<!-- -->
<span></span><span class="hljs-function" style="color:#f92672;font-weight:bold">func</span><span class="hljs-function"> </span><span class="hljs-function" style="color:#a6e22e;font-weight:bold">main</span><span class="hljs-function hljs-params">()</span><span> {
</span><span>	helloHandler := </span><span style="color:#a6e22e">new</span><span>(HelloHandler)
</span><span>	worldHandler := </span><span style="color:#a6e22e">new</span><span>(WorldHandler)
</span>	server := http.Server{
<span>		Addr: </span><span style="color:#a6e22e">&quot;0.0.0.0:8080&quot;</span><span>,
</span>	}
<span>	http.Handle(</span><span style="color:#a6e22e">&quot;/hello&quot;</span><span>, helloHandler)
</span><span>	http.Handle(</span><span style="color:#a6e22e">&quot;/world&quot;</span><span>, worldHandler)
</span><span>	http.HandleFunc(</span><span style="color:#a6e22e">&quot;/hello2&quot;</span><span>, hello)
</span><span>	http.HandleFunc(</span><span style="color:#a6e22e">&quot;/world2&quot;</span><span>, world)
</span>	server.ListenAndServe()
<!-- -->}
</code></div></pre>
<h3>何が違うのか</h3>
<p>やってることは <code node="[object Object]">DefaultServeMux.Handle(pattern, handler)** なので同じ. 既存のインターフェースがある場合は, </code>ServeHTTP<code node="[object Object]">メソッドを追加するだけでハンドラになるからそういった場合は,</code>http.Handle` のほうが手軽.</p>
<pre><div node="[object Object]" style="display:block;overflow-x:auto;padding:0.5em;background:#272822;color:#ddd"><code class="language-go" style="white-space:pre"><span class="hljs-function" style="color:#f92672;font-weight:bold">func</span><span class="hljs-function"> </span><span class="hljs-function" style="color:#a6e22e;font-weight:bold">Handle</span><span class="hljs-function hljs-params">(pattern </span><span class="hljs-function hljs-params" style="color:#f92672;font-weight:bold">string</span><span class="hljs-function hljs-params">, handler Handler)</span><span> { DefaultServeMux.Handle(pattern, handler) }
</span>
<span></span><span class="hljs-function" style="color:#f92672;font-weight:bold">func</span><span class="hljs-function"> </span><span class="hljs-function" style="color:#a6e22e;font-weight:bold">HandleFunc</span><span class="hljs-function hljs-params">(pattern </span><span class="hljs-function hljs-params" style="color:#f92672;font-weight:bold">string</span><span class="hljs-function hljs-params">, handler </span><span class="hljs-function hljs-params" style="color:#f92672;font-weight:bold">func</span><span class="hljs-function hljs-params">(ResponseWriter, *Request)</span><span class="hljs-function">)</span><span> {
</span>	DefaultServeMux.HandleFunc(pattern, handler)
<!-- -->}
<!-- -->
<span></span><span class="hljs-function" style="color:#f92672;font-weight:bold">func</span><span class="hljs-function"> </span><span class="hljs-function hljs-params">(mux *ServeMux)</span><span class="hljs-function"> </span><span class="hljs-function" style="color:#a6e22e;font-weight:bold">HandleFunc</span><span class="hljs-function hljs-params">(pattern </span><span class="hljs-function hljs-params" style="color:#f92672;font-weight:bold">string</span><span class="hljs-function hljs-params">, handler </span><span class="hljs-function hljs-params" style="color:#f92672;font-weight:bold">func</span><span class="hljs-function hljs-params">(ResponseWriter, *Request)</span><span class="hljs-function">)</span><span> {
</span><span>	</span><span style="color:#f92672;font-weight:bold">if</span><span> handler == </span><span style="color:#f92672;font-weight:bold">nil</span><span> {
</span><span>		</span><span style="color:#a6e22e">panic</span><span>(</span><span style="color:#a6e22e">&quot;http: nil handler&quot;</span><span>)
</span>	}
<!-- -->	mux.Handle(pattern, HandlerFunc(handler))
<!-- -->}
</code></div></pre>
<h2>サードパーティー製のマルチプレクサ</h2>
<p>標準でも特に辛くない. <code node="[object Object]">request.Method</code> でメソッドも取得できるのでかなり使い勝手もいい.</p>
<pre><div node="[object Object]" style="display:block;overflow-x:auto;padding:0.5em;background:#272822;color:#ddd"><code class="language-go" style="white-space:pre"><span>mux.HandleFunc(</span><span style="color:#a6e22e">&quot;/users/create&quot;</span><span>, createUsers)
</span><span>mux.HandleFunc(</span><span style="color:#a6e22e">&quot;/users/read/&quot;</span><span>, readUsers)
</span><span>mux.HandleFunc(</span><span style="color:#a6e22e">&quot;/users/update/&quot;</span><span>, updateUsers)
</span><span>mux.HandleFunc(</span><span style="color:#a6e22e">&quot;/users/delete/&quot;</span><span>, deleteUsers)
</span>
<span></span><span class="hljs-function" style="color:#f92672;font-weight:bold">func</span><span class="hljs-function"> </span><span class="hljs-function" style="color:#a6e22e;font-weight:bold">readerUsers</span><span class="hljs-function hljs-params">(writer http.ResponseWriter, request *http.Request)</span><span> {
</span><span>	sub := strings.TrimPrefix(request.URL.Path, </span><span style="color:#a6e22e">&quot;/users/read/&quot;</span><span>)
</span><span>	userId, err := strconv.Atoi(sub) </span><span style="color:#75715e">// これで /users/read/:id の id を取得できる</span><span>
</span>}
</code></div></pre>
<p>下記のような, <code node="[object Object]">/users/:user_id/tasks/:task_id</code> みたいに解析を結構頑張らないといけない場合は結構辛い.</p>
<pre><div node="[object Object]" style="display:block;overflow-x:auto;padding:0.5em;background:#272822;color:#ddd"><code class="language-go" style="white-space:pre"><span>mux.HandleFunc(</span><span style="color:#a6e22e">&quot;/users/2/tasks/create&quot;</span><span>, createUsers)
</span><span>mux.HandleFunc(</span><span style="color:#a6e22e">&quot;/users/2/tasks/read/&quot;</span><span>, readUsers)
</span><span>mux.HandleFunc(</span><span style="color:#a6e22e">&quot;/users/2/tasks/update/&quot;</span><span>, updateUsers)
</span><span>mux.HandleFunc(</span><span style="color:#a6e22e">&quot;/users/2/tasks/delete/&quot;</span><span>, deleteUsers)</span></code></div></pre>
<p>この辺が良さそう.</p>
<ul>
<li><a href="https://github.com/gorilla/mux">https://github.com/gorilla/mux</a></li>
<li><a href="https://github.com/julienschmidt/httprouter">https://github.com/julienschmidt/httprouter</a></li>
</ul> </div><br/></div></div><script id="__NEXT_DATA__" type="application/json">{"props":{"pageProps":{"data":{"id":"20210723021243","fileContents":"{\n  \"title\": \"Golang の http/net について調べた\",\n  \"date\": 20210723021243,\n  \"tags\": [\n    \"golang\"\n  ],\n  \"bodyContent\": \"## サーバ\\n何もしないサーバを起動.\\n```go\\npackage main\\n\\nimport \\\"net/http\\\"\\n\\nfunc main() {\\n\\thttp.ListenAndServe(\\\"\\\", nil)\\n}\\n```\\n\\n`ListenAndServe` は ネットワークアドレスとハンドラを引数で受け取る.ハンドラが nil の場合は `DefaultServerMux` が使われる.\\n\\nServer の構造体はこんな感じ.\\n```go\\ntype Server struct {\\n\\tAddr string\\n\\tHandler Handler\\n\\tTLSConfig *tls.Config\\n\\tReadTimeout time.Duration\\n\\tReadHeaderTimeout time.Duration\\n\\tWriteTimeout time.Duration\\n\\tIdleTimeout time.Duration\\n\\tMaxHeaderBytes int\\n\\tTLSNextProto map[string]func(*Server, *tls.Conn, Handler)\\n\\tConnState func(net.Conn, ConnState)\\n\\tErrorLog *log.Logger\\n\\tBaseContext func(net.Listener) context.Context\\n\\tConnContext func(ctx context.Context, c net.Conn) context.Context\\n\\tinShutdown atomicBool\\n\\tdisableKeepAlives int32\\n\\tnextProtoOnce     sync.Once\\n\\tnextProtoErr      error\\n\\tmu         sync.Mutex\\n\\tlisteners  map[*net.Listener]struct{}\\n\\tactiveConn map[*conn]struct{}\\n\\tdoneChan   chan struct{}\\n\\tonShutdown []func()\\n}\\n```\\n\\n設定を変更する場合は Server の構造体に値を指定する.\\n```go\\nfunc main() {\\n\\tserver := http.Server{\\n\\t\\tAddr:    \\\"0.0.0.0:8080\\\",\\n\\t\\tHandler: nil,\\n\\t}\\n\\tserver.ListenAndServe()\\n```\\n\\n### ハンドラとハンドラ関数\\nハンドラがない場合すべてのリクエストで 404 を返す.\\n\\nハンドラとは, `ServerHTTP メソッド` を持ったインターフェースのことを指す.\\nこのメソッドは, `インターフェース HTTPResponseWriter` と `構造体 Request のポインタ` の 2 つの引数を取る.\\nつまり, `ServerHTTP(http.ResponseWriter, *http.Request)` をもつインターフェースがハンドラになる.\\n```go\\ntype HelloHandler struct{}\\n\\nfunc (h *HelloHandler) ServeHTTP(writer http.ResponseWriter, request *http.Request) {\\n\\tfmt.Fprintf(writer, \\\"hello\\\")\\n}\\n\\nfunc main() {\\n\\thelloHandler := new(HelloHandler)\\n\\tserver := http.Server{\\n\\t\\tAddr:    \\\"0.0.0.0:8080\\\",\\n\\t\\tHandler: helloHandler,\\n\\t}\\n\\tserver.ListenAndServe()\\n}\\n```\\n\\nこの状態だと,すべてのアクセスが 1 つのハンドラに行く.\\n\\n実際は URL ごとに異なるハンドラで処理する必要があるため Handler フィールドに値を指定しない (デフォルトで DefaultServerMux を使う) .\\n\\n```go\\ntype HelloHandler struct{}\\ntype WorldHandler struct{}\\n\\nfunc (h *HelloHandler) ServeHTTP(writer http.ResponseWriter, request *http.Request) {\\n\\tfmt.Fprintf(writer, \\\"hello\\\")\\n}\\nfunc (w *WorldHandler) ServeHTTP(writer http.ResponseWriter, request *http.Request) {\\n\\tfmt.Fprintf(writer, \\\"world\\\")\\n}\\n\\nfunc main() {\\n\\thelloHandler := new(HelloHandler)\\n\\tworldHandler := new(WorldHandler)\\n\\tserver := http.Server{\\n\\t\\tAddr: \\\"0.0.0.0:8080\\\",\\n\\t}\\n\\thttp.Handle(\\\"/hello\\\", helloHandler)\\n\\thttp.Handle(\\\"/world\\\", worldHandler)\\n\\tserver.ListenAndServe()\\n}\\n```\\n\\n`http.Handle` は実際には DefaultServeMux の Handle メソッドを呼び出している.\\n\\n```go\\nfunc Handle(pattern string, handler Handler) { DefaultServeMux.Handle(pattern, handler) }\\n```\\n\\nハンドラとは, `ServerHTTP(http.ResponseWriter, *http.Request)` をもつインターフェース のこと.\\nハンドラ関数とは,ハンドラのように振る舞う関数.リクエストのポインタを受け取ることができる.\\n\\n```go\\npackage main\\n\\nimport (\\n\\t\\\"fmt\\\"\\n\\t\\\"net/http\\\"\\n)\\n\\ntype HelloHandler struct{}\\ntype WorldHandler struct{}\\n\\nfunc (h *HelloHandler) ServeHTTP(writer http.ResponseWriter, request *http.Request) {\\n\\tfmt.Fprintf(writer, \\\"hello\\\")\\n}\\nfunc (w *WorldHandler) ServeHTTP(writer http.ResponseWriter, request *http.Request) {\\n\\tfmt.Fprintf(writer, \\\"world\\\")\\n}\\n\\nfunc hello(writer http.ResponseWriter, request *http.Request) {\\n\\tfmt.Fprintf(writer, \\\"hello\\\")\\n}\\nfunc world(writer http.ResponseWriter, request *http.Request) {\\n\\tfmt.Fprintf(writer, \\\"world\\\")\\n}\\n\\nfunc main() {\\n\\thelloHandler := new(HelloHandler)\\n\\tworldHandler := new(WorldHandler)\\n\\tserver := http.Server{\\n\\t\\tAddr: \\\"0.0.0.0:8080\\\",\\n\\t}\\n\\thttp.Handle(\\\"/hello\\\", helloHandler)\\n\\thttp.Handle(\\\"/world\\\", worldHandler)\\n\\thttp.HandleFunc(\\\"/hello2\\\", hello)\\n\\thttp.HandleFunc(\\\"/world2\\\", world)\\n\\tserver.ListenAndServe()\\n}\\n```\\n\\n### 何が違うのか\\nやってることは `DefaultServeMux.Handle(pattern, handler)** なので同じ.\\n既存のインターフェースがある場合は, `ServeHTTP` メソッドを追加するだけでハンドラになるからそういった場合は, `http.Handle` のほうが手軽.\\n\\n```go\\nfunc Handle(pattern string, handler Handler) { DefaultServeMux.Handle(pattern, handler) }\\n\\nfunc HandleFunc(pattern string, handler func(ResponseWriter, *Request)) {\\n\\tDefaultServeMux.HandleFunc(pattern, handler)\\n}\\n\\nfunc (mux *ServeMux) HandleFunc(pattern string, handler func(ResponseWriter, *Request)) {\\n\\tif handler == nil {\\n\\t\\tpanic(\\\"http: nil handler\\\")\\n\\t}\\n\\tmux.Handle(pattern, HandlerFunc(handler))\\n}\\n```\\n\\n## サードパーティー製のマルチプレクサ\\n標準でも特に辛くない. `request.Method` でメソッドも取得できるのでかなり使い勝手もいい.\\n```go\\nmux.HandleFunc(\\\"/users/create\\\", createUsers)\\nmux.HandleFunc(\\\"/users/read/\\\", readUsers)\\nmux.HandleFunc(\\\"/users/update/\\\", updateUsers)\\nmux.HandleFunc(\\\"/users/delete/\\\", deleteUsers)\\n\\nfunc readerUsers(writer http.ResponseWriter, request *http.Request) {\\n\\tsub := strings.TrimPrefix(request.URL.Path, \\\"/users/read/\\\")\\n\\tuserId, err := strconv.Atoi(sub) // これで /users/read/:id の id を取得できる\\n}\\n```\\n\\n下記のような, `/users/:user_id/tasks/:task_id` みたいに解析を結構頑張らないといけない場合は結構辛い.\\n```go\\nmux.HandleFunc(\\\"/users/2/tasks/create\\\", createUsers)\\nmux.HandleFunc(\\\"/users/2/tasks/read/\\\", readUsers)\\nmux.HandleFunc(\\\"/users/2/tasks/update/\\\", updateUsers)\\nmux.HandleFunc(\\\"/users/2/tasks/delete/\\\", deleteUsers)\\n```\\n\\nこの辺が良さそう.\\n- https://github.com/gorilla/mux\\n- https://github.com/julienschmidt/httprouter\",\n  \"bodyHtml\": \"\u003ch2\u003eサーバ\u003c/h2\u003e\\n\u003cp\u003e何もしないサーバを起動.\u003c/p\u003e\\n\u003cpre\u003e\u003ccode class=\\\"hljs\\\"\u003e\u003cspan class=\\\"hljs-keyword\\\"\u003epackage\u003c/span\u003e main\\n\\n\u003cspan class=\\\"hljs-keyword\\\"\u003eimport\u003c/span\u003e \u003cspan class=\\\"hljs-string\\\"\u003e\u0026quot;net/http\u0026quot;\u003c/span\u003e\\n\\n\u003cspan class=\\\"hljs-function\\\"\u003e\u003cspan class=\\\"hljs-keyword\\\"\u003efunc\u003c/span\u003e \u003cspan class=\\\"hljs-title\\\"\u003emain\u003c/span\u003e\u003cspan class=\\\"hljs-params\\\"\u003e()\u003c/span\u003e\u003c/span\u003e {\\n\\thttp.ListenAndServe(\u003cspan class=\\\"hljs-string\\\"\u003e\u0026quot;\u0026quot;\u003c/span\u003e, \u003cspan class=\\\"hljs-literal\\\"\u003enil\u003c/span\u003e)\\n}\u003c/code\u003e\u003c/pre\u003e\u003cp\u003e\u003ccode\u003eListenAndServe\u003c/code\u003e は ネットワークアドレスとハンドラを引数で受け取る.ハンドラが nil の場合は \u003ccode\u003eDefaultServerMux\u003c/code\u003e が使われる.\u003c/p\u003e\\n\u003cp\u003eServer の構造体はこんな感じ.\u003c/p\u003e\\n\u003cpre\u003e\u003ccode class=\\\"hljs\\\"\u003e\u003cspan class=\\\"hljs-keyword\\\"\u003etype\u003c/span\u003e Server \u003cspan class=\\\"hljs-keyword\\\"\u003estruct\u003c/span\u003e {\\n\\tAddr \u003cspan class=\\\"hljs-keyword\\\"\u003estring\u003c/span\u003e\\n\\tHandler Handler\\n\\tTLSConfig *tls.Config\\n\\tReadTimeout time.Duration\\n\\tReadHeaderTimeout time.Duration\\n\\tWriteTimeout time.Duration\\n\\tIdleTimeout time.Duration\\n\\tMaxHeaderBytes \u003cspan class=\\\"hljs-keyword\\\"\u003eint\u003c/span\u003e\\n\\tTLSNextProto \u003cspan class=\\\"hljs-keyword\\\"\u003emap\u003c/span\u003e[\u003cspan class=\\\"hljs-keyword\\\"\u003estring\u003c/span\u003e]\u003cspan class=\\\"hljs-function\\\"\u003e\u003cspan class=\\\"hljs-keyword\\\"\u003efunc\u003c/span\u003e\u003cspan class=\\\"hljs-params\\\"\u003e(*Server, *tls.Conn, Handler)\u003c/span\u003e\u003c/span\u003e\\n\\tConnState \u003cspan class=\\\"hljs-function\\\"\u003e\u003cspan class=\\\"hljs-keyword\\\"\u003efunc\u003c/span\u003e\u003cspan class=\\\"hljs-params\\\"\u003e(net.Conn, ConnState)\u003c/span\u003e\u003c/span\u003e\\n\\tErrorLog *log.Logger\\n\\tBaseContext \u003cspan class=\\\"hljs-function\\\"\u003e\u003cspan class=\\\"hljs-keyword\\\"\u003efunc\u003c/span\u003e\u003cspan class=\\\"hljs-params\\\"\u003e(net.Listener)\u003c/span\u003e \u003cspan class=\\\"hljs-title\\\"\u003econtext\u003c/span\u003e.\u003cspan class=\\\"hljs-title\\\"\u003eContext\u003c/span\u003e\u003c/span\u003e\\n\\tConnContext \u003cspan class=\\\"hljs-function\\\"\u003e\u003cspan class=\\\"hljs-keyword\\\"\u003efunc\u003c/span\u003e\u003cspan class=\\\"hljs-params\\\"\u003e(ctx context.Context, c net.Conn)\u003c/span\u003e \u003cspan class=\\\"hljs-title\\\"\u003econtext\u003c/span\u003e.\u003cspan class=\\\"hljs-title\\\"\u003eContext\u003c/span\u003e\u003c/span\u003e\\n\\tinShutdown atomicBool\\n\\tdisableKeepAlives \u003cspan class=\\\"hljs-keyword\\\"\u003eint32\u003c/span\u003e\\n\\tnextProtoOnce     sync.Once\\n\\tnextProtoErr      error\\n\\tmu         sync.Mutex\\n\\tlisteners  \u003cspan class=\\\"hljs-keyword\\\"\u003emap\u003c/span\u003e[*net.Listener]\u003cspan class=\\\"hljs-keyword\\\"\u003estruct\u003c/span\u003e{}\\n\\tactiveConn \u003cspan class=\\\"hljs-keyword\\\"\u003emap\u003c/span\u003e[*conn]\u003cspan class=\\\"hljs-keyword\\\"\u003estruct\u003c/span\u003e{}\\n\\tdoneChan   \u003cspan class=\\\"hljs-keyword\\\"\u003echan\u003c/span\u003e \u003cspan class=\\\"hljs-keyword\\\"\u003estruct\u003c/span\u003e{}\\n\\tonShutdown []\u003cspan class=\\\"hljs-function\\\"\u003e\u003cspan class=\\\"hljs-keyword\\\"\u003efunc\u003c/span\u003e\u003cspan class=\\\"hljs-params\\\"\u003e()\u003c/span\u003e\u003c/span\u003e\\n}\u003c/code\u003e\u003c/pre\u003e\u003cp\u003e設定を変更する場合は Server の構造体に値を指定する.\u003c/p\u003e\\n\u003cpre\u003e\u003ccode class=\\\"hljs\\\"\u003e\u003cspan class=\\\"hljs-function\\\"\u003e\u003cspan class=\\\"hljs-keyword\\\"\u003efunc\u003c/span\u003e \u003cspan class=\\\"hljs-title\\\"\u003emain\u003c/span\u003e\u003cspan class=\\\"hljs-params\\\"\u003e()\u003c/span\u003e\u003c/span\u003e {\\n\\tserver := http.Server{\\n\\t\\tAddr:    \u003cspan class=\\\"hljs-string\\\"\u003e\u0026quot;0.0.0.0:8080\u0026quot;\u003c/span\u003e,\\n\\t\\tHandler: \u003cspan class=\\\"hljs-literal\\\"\u003enil\u003c/span\u003e,\\n\\t}\\n\\tserver.ListenAndServe()\u003c/code\u003e\u003c/pre\u003e\u003ch3\u003eハンドラとハンドラ関数\u003c/h3\u003e\\n\u003cp\u003eハンドラがない場合すべてのリクエストで 404 を返す.\u003c/p\u003e\\n\u003cp\u003eハンドラとは, \u003ccode\u003eServerHTTP メソッド\u003c/code\u003e を持ったインターフェースのことを指す.\\nこのメソッドは, \u003ccode\u003eインターフェース HTTPResponseWriter\u003c/code\u003e と \u003ccode\u003e構造体 Request のポインタ\u003c/code\u003e の 2 つの引数を取る.\\nつまり, \u003ccode\u003eServerHTTP(http.ResponseWriter, *http.Request)\u003c/code\u003e をもつインターフェースがハンドラになる.\u003c/p\u003e\\n\u003cpre\u003e\u003ccode class=\\\"hljs\\\"\u003e\u003cspan class=\\\"hljs-keyword\\\"\u003etype\u003c/span\u003e HelloHandler \u003cspan class=\\\"hljs-keyword\\\"\u003estruct\u003c/span\u003e{}\\n\\n\u003cspan class=\\\"hljs-function\\\"\u003e\u003cspan class=\\\"hljs-keyword\\\"\u003efunc\u003c/span\u003e \u003cspan class=\\\"hljs-params\\\"\u003e(h *HelloHandler)\u003c/span\u003e \u003cspan class=\\\"hljs-title\\\"\u003eServeHTTP\u003c/span\u003e\u003cspan class=\\\"hljs-params\\\"\u003e(writer http.ResponseWriter, request *http.Request)\u003c/span\u003e\u003c/span\u003e {\\n\\tfmt.Fprintf(writer, \u003cspan class=\\\"hljs-string\\\"\u003e\u0026quot;hello\u0026quot;\u003c/span\u003e)\\n}\\n\\n\u003cspan class=\\\"hljs-function\\\"\u003e\u003cspan class=\\\"hljs-keyword\\\"\u003efunc\u003c/span\u003e \u003cspan class=\\\"hljs-title\\\"\u003emain\u003c/span\u003e\u003cspan class=\\\"hljs-params\\\"\u003e()\u003c/span\u003e\u003c/span\u003e {\\n\\thelloHandler := \u003cspan class=\\\"hljs-built_in\\\"\u003enew\u003c/span\u003e(HelloHandler)\\n\\tserver := http.Server{\\n\\t\\tAddr:    \u003cspan class=\\\"hljs-string\\\"\u003e\u0026quot;0.0.0.0:8080\u0026quot;\u003c/span\u003e,\\n\\t\\tHandler: helloHandler,\\n\\t}\\n\\tserver.ListenAndServe()\\n}\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eこの状態だと,すべてのアクセスが 1 つのハンドラに行く.\u003c/p\u003e\\n\u003cp\u003e実際は URL ごとに異なるハンドラで処理する必要があるため Handler フィールドに値を指定しない (デフォルトで DefaultServerMux を使う) .\u003c/p\u003e\\n\u003cpre\u003e\u003ccode class=\\\"hljs\\\"\u003e\u003cspan class=\\\"hljs-keyword\\\"\u003etype\u003c/span\u003e HelloHandler \u003cspan class=\\\"hljs-keyword\\\"\u003estruct\u003c/span\u003e{}\\n\u003cspan class=\\\"hljs-keyword\\\"\u003etype\u003c/span\u003e WorldHandler \u003cspan class=\\\"hljs-keyword\\\"\u003estruct\u003c/span\u003e{}\\n\\n\u003cspan class=\\\"hljs-function\\\"\u003e\u003cspan class=\\\"hljs-keyword\\\"\u003efunc\u003c/span\u003e \u003cspan class=\\\"hljs-params\\\"\u003e(h *HelloHandler)\u003c/span\u003e \u003cspan class=\\\"hljs-title\\\"\u003eServeHTTP\u003c/span\u003e\u003cspan class=\\\"hljs-params\\\"\u003e(writer http.ResponseWriter, request *http.Request)\u003c/span\u003e\u003c/span\u003e {\\n\\tfmt.Fprintf(writer, \u003cspan class=\\\"hljs-string\\\"\u003e\u0026quot;hello\u0026quot;\u003c/span\u003e)\\n}\\n\u003cspan class=\\\"hljs-function\\\"\u003e\u003cspan class=\\\"hljs-keyword\\\"\u003efunc\u003c/span\u003e \u003cspan class=\\\"hljs-params\\\"\u003e(w *WorldHandler)\u003c/span\u003e \u003cspan class=\\\"hljs-title\\\"\u003eServeHTTP\u003c/span\u003e\u003cspan class=\\\"hljs-params\\\"\u003e(writer http.ResponseWriter, request *http.Request)\u003c/span\u003e\u003c/span\u003e {\\n\\tfmt.Fprintf(writer, \u003cspan class=\\\"hljs-string\\\"\u003e\u0026quot;world\u0026quot;\u003c/span\u003e)\\n}\\n\\n\u003cspan class=\\\"hljs-function\\\"\u003e\u003cspan class=\\\"hljs-keyword\\\"\u003efunc\u003c/span\u003e \u003cspan class=\\\"hljs-title\\\"\u003emain\u003c/span\u003e\u003cspan class=\\\"hljs-params\\\"\u003e()\u003c/span\u003e\u003c/span\u003e {\\n\\thelloHandler := \u003cspan class=\\\"hljs-built_in\\\"\u003enew\u003c/span\u003e(HelloHandler)\\n\\tworldHandler := \u003cspan class=\\\"hljs-built_in\\\"\u003enew\u003c/span\u003e(WorldHandler)\\n\\tserver := http.Server{\\n\\t\\tAddr: \u003cspan class=\\\"hljs-string\\\"\u003e\u0026quot;0.0.0.0:8080\u0026quot;\u003c/span\u003e,\\n\\t}\\n\\thttp.Handle(\u003cspan class=\\\"hljs-string\\\"\u003e\u0026quot;/hello\u0026quot;\u003c/span\u003e, helloHandler)\\n\\thttp.Handle(\u003cspan class=\\\"hljs-string\\\"\u003e\u0026quot;/world\u0026quot;\u003c/span\u003e, worldHandler)\\n\\tserver.ListenAndServe()\\n}\u003c/code\u003e\u003c/pre\u003e\u003cp\u003e\u003ccode\u003ehttp.Handle\u003c/code\u003e は実際には DefaultServeMux の Handle メソッドを呼び出している.\u003c/p\u003e\\n\u003cpre\u003e\u003ccode class=\\\"hljs\\\"\u003e\u003cspan class=\\\"hljs-function\\\"\u003e\u003cspan class=\\\"hljs-keyword\\\"\u003efunc\u003c/span\u003e \u003cspan class=\\\"hljs-title\\\"\u003eHandle\u003c/span\u003e\u003cspan class=\\\"hljs-params\\\"\u003e(pattern \u003cspan class=\\\"hljs-keyword\\\"\u003estring\u003c/span\u003e, handler Handler)\u003c/span\u003e\u003c/span\u003e { DefaultServeMux.Handle(pattern, handler) }\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eハンドラとは, \u003ccode\u003eServerHTTP(http.ResponseWriter, *http.Request)\u003c/code\u003e をもつインターフェース のこと.\\nハンドラ関数とは,ハンドラのように振る舞う関数.リクエストのポインタを受け取ることができる.\u003c/p\u003e\\n\u003cpre\u003e\u003ccode class=\\\"hljs\\\"\u003e\u003cspan class=\\\"hljs-keyword\\\"\u003epackage\u003c/span\u003e main\\n\\n\u003cspan class=\\\"hljs-keyword\\\"\u003eimport\u003c/span\u003e (\\n\\t\u003cspan class=\\\"hljs-string\\\"\u003e\u0026quot;fmt\u0026quot;\u003c/span\u003e\\n\\t\u003cspan class=\\\"hljs-string\\\"\u003e\u0026quot;net/http\u0026quot;\u003c/span\u003e\\n)\\n\\n\u003cspan class=\\\"hljs-keyword\\\"\u003etype\u003c/span\u003e HelloHandler \u003cspan class=\\\"hljs-keyword\\\"\u003estruct\u003c/span\u003e{}\\n\u003cspan class=\\\"hljs-keyword\\\"\u003etype\u003c/span\u003e WorldHandler \u003cspan class=\\\"hljs-keyword\\\"\u003estruct\u003c/span\u003e{}\\n\\n\u003cspan class=\\\"hljs-function\\\"\u003e\u003cspan class=\\\"hljs-keyword\\\"\u003efunc\u003c/span\u003e \u003cspan class=\\\"hljs-params\\\"\u003e(h *HelloHandler)\u003c/span\u003e \u003cspan class=\\\"hljs-title\\\"\u003eServeHTTP\u003c/span\u003e\u003cspan class=\\\"hljs-params\\\"\u003e(writer http.ResponseWriter, request *http.Request)\u003c/span\u003e\u003c/span\u003e {\\n\\tfmt.Fprintf(writer, \u003cspan class=\\\"hljs-string\\\"\u003e\u0026quot;hello\u0026quot;\u003c/span\u003e)\\n}\\n\u003cspan class=\\\"hljs-function\\\"\u003e\u003cspan class=\\\"hljs-keyword\\\"\u003efunc\u003c/span\u003e \u003cspan class=\\\"hljs-params\\\"\u003e(w *WorldHandler)\u003c/span\u003e \u003cspan class=\\\"hljs-title\\\"\u003eServeHTTP\u003c/span\u003e\u003cspan class=\\\"hljs-params\\\"\u003e(writer http.ResponseWriter, request *http.Request)\u003c/span\u003e\u003c/span\u003e {\\n\\tfmt.Fprintf(writer, \u003cspan class=\\\"hljs-string\\\"\u003e\u0026quot;world\u0026quot;\u003c/span\u003e)\\n}\\n\\n\u003cspan class=\\\"hljs-function\\\"\u003e\u003cspan class=\\\"hljs-keyword\\\"\u003efunc\u003c/span\u003e \u003cspan class=\\\"hljs-title\\\"\u003ehello\u003c/span\u003e\u003cspan class=\\\"hljs-params\\\"\u003e(writer http.ResponseWriter, request *http.Request)\u003c/span\u003e\u003c/span\u003e {\\n\\tfmt.Fprintf(writer, \u003cspan class=\\\"hljs-string\\\"\u003e\u0026quot;hello\u0026quot;\u003c/span\u003e)\\n}\\n\u003cspan class=\\\"hljs-function\\\"\u003e\u003cspan class=\\\"hljs-keyword\\\"\u003efunc\u003c/span\u003e \u003cspan class=\\\"hljs-title\\\"\u003eworld\u003c/span\u003e\u003cspan class=\\\"hljs-params\\\"\u003e(writer http.ResponseWriter, request *http.Request)\u003c/span\u003e\u003c/span\u003e {\\n\\tfmt.Fprintf(writer, \u003cspan class=\\\"hljs-string\\\"\u003e\u0026quot;world\u0026quot;\u003c/span\u003e)\\n}\\n\\n\u003cspan class=\\\"hljs-function\\\"\u003e\u003cspan class=\\\"hljs-keyword\\\"\u003efunc\u003c/span\u003e \u003cspan class=\\\"hljs-title\\\"\u003emain\u003c/span\u003e\u003cspan class=\\\"hljs-params\\\"\u003e()\u003c/span\u003e\u003c/span\u003e {\\n\\thelloHandler := \u003cspan class=\\\"hljs-built_in\\\"\u003enew\u003c/span\u003e(HelloHandler)\\n\\tworldHandler := \u003cspan class=\\\"hljs-built_in\\\"\u003enew\u003c/span\u003e(WorldHandler)\\n\\tserver := http.Server{\\n\\t\\tAddr: \u003cspan class=\\\"hljs-string\\\"\u003e\u0026quot;0.0.0.0:8080\u0026quot;\u003c/span\u003e,\\n\\t}\\n\\thttp.Handle(\u003cspan class=\\\"hljs-string\\\"\u003e\u0026quot;/hello\u0026quot;\u003c/span\u003e, helloHandler)\\n\\thttp.Handle(\u003cspan class=\\\"hljs-string\\\"\u003e\u0026quot;/world\u0026quot;\u003c/span\u003e, worldHandler)\\n\\thttp.HandleFunc(\u003cspan class=\\\"hljs-string\\\"\u003e\u0026quot;/hello2\u0026quot;\u003c/span\u003e, hello)\\n\\thttp.HandleFunc(\u003cspan class=\\\"hljs-string\\\"\u003e\u0026quot;/world2\u0026quot;\u003c/span\u003e, world)\\n\\tserver.ListenAndServe()\\n}\u003c/code\u003e\u003c/pre\u003e\u003ch3\u003e何が違うのか\u003c/h3\u003e\\n\u003cp\u003eやってることは \u003ccode\u003eDefaultServeMux.Handle(pattern, handler)** なので同じ. 既存のインターフェースがある場合は, \u003c/code\u003eServeHTTP\u003ccode\u003eメソッドを追加するだけでハンドラになるからそういった場合は,\u003c/code\u003ehttp.Handle` のほうが手軽.\u003c/p\u003e\\n\u003cpre\u003e\u003ccode class=\\\"hljs\\\"\u003e\u003cspan class=\\\"hljs-function\\\"\u003e\u003cspan class=\\\"hljs-keyword\\\"\u003efunc\u003c/span\u003e \u003cspan class=\\\"hljs-title\\\"\u003eHandle\u003c/span\u003e\u003cspan class=\\\"hljs-params\\\"\u003e(pattern \u003cspan class=\\\"hljs-keyword\\\"\u003estring\u003c/span\u003e, handler Handler)\u003c/span\u003e\u003c/span\u003e { DefaultServeMux.Handle(pattern, handler) }\\n\\n\u003cspan class=\\\"hljs-function\\\"\u003e\u003cspan class=\\\"hljs-keyword\\\"\u003efunc\u003c/span\u003e \u003cspan class=\\\"hljs-title\\\"\u003eHandleFunc\u003c/span\u003e\u003cspan class=\\\"hljs-params\\\"\u003e(pattern \u003cspan class=\\\"hljs-keyword\\\"\u003estring\u003c/span\u003e, handler \u003cspan class=\\\"hljs-keyword\\\"\u003efunc\u003c/span\u003e(ResponseWriter, *Request)\u003c/span\u003e)\u003c/span\u003e {\\n\\tDefaultServeMux.HandleFunc(pattern, handler)\\n}\\n\\n\u003cspan class=\\\"hljs-function\\\"\u003e\u003cspan class=\\\"hljs-keyword\\\"\u003efunc\u003c/span\u003e \u003cspan class=\\\"hljs-params\\\"\u003e(mux *ServeMux)\u003c/span\u003e \u003cspan class=\\\"hljs-title\\\"\u003eHandleFunc\u003c/span\u003e\u003cspan class=\\\"hljs-params\\\"\u003e(pattern \u003cspan class=\\\"hljs-keyword\\\"\u003estring\u003c/span\u003e, handler \u003cspan class=\\\"hljs-keyword\\\"\u003efunc\u003c/span\u003e(ResponseWriter, *Request)\u003c/span\u003e)\u003c/span\u003e {\\n\\t\u003cspan class=\\\"hljs-keyword\\\"\u003eif\u003c/span\u003e handler == \u003cspan class=\\\"hljs-literal\\\"\u003enil\u003c/span\u003e {\\n\\t\\t\u003cspan class=\\\"hljs-built_in\\\"\u003epanic\u003c/span\u003e(\u003cspan class=\\\"hljs-string\\\"\u003e\u0026quot;http: nil handler\u0026quot;\u003c/span\u003e)\\n\\t}\\n\\tmux.Handle(pattern, HandlerFunc(handler))\\n}\u003c/code\u003e\u003c/pre\u003e\u003ch2\u003eサードパーティー製のマルチプレクサ\u003c/h2\u003e\\n\u003cp\u003e標準でも特に辛くない. \u003ccode\u003erequest.Method\u003c/code\u003e でメソッドも取得できるのでかなり使い勝手もいい.\u003c/p\u003e\\n\u003cpre\u003e\u003ccode class=\\\"hljs\\\"\u003emux.HandleFunc(\u003cspan class=\\\"hljs-string\\\"\u003e\u0026quot;/users/create\u0026quot;\u003c/span\u003e, createUsers)\\nmux.HandleFunc(\u003cspan class=\\\"hljs-string\\\"\u003e\u0026quot;/users/read/\u0026quot;\u003c/span\u003e, readUsers)\\nmux.HandleFunc(\u003cspan class=\\\"hljs-string\\\"\u003e\u0026quot;/users/update/\u0026quot;\u003c/span\u003e, updateUsers)\\nmux.HandleFunc(\u003cspan class=\\\"hljs-string\\\"\u003e\u0026quot;/users/delete/\u0026quot;\u003c/span\u003e, deleteUsers)\\n\\n\u003cspan class=\\\"hljs-function\\\"\u003e\u003cspan class=\\\"hljs-keyword\\\"\u003efunc\u003c/span\u003e \u003cspan class=\\\"hljs-title\\\"\u003ereaderUsers\u003c/span\u003e\u003cspan class=\\\"hljs-params\\\"\u003e(writer http.ResponseWriter, request *http.Request)\u003c/span\u003e\u003c/span\u003e {\\n\\tsub := strings.TrimPrefix(request.URL.Path, \u003cspan class=\\\"hljs-string\\\"\u003e\u0026quot;/users/read/\u0026quot;\u003c/span\u003e)\\n\\tuserId, err := strconv.Atoi(sub) \u003cspan class=\\\"hljs-comment\\\"\u003e// これで /users/read/:id の id を取得できる\u003c/span\u003e\\n}\u003c/code\u003e\u003c/pre\u003e\u003cp\u003e下記のような, \u003ccode\u003e/users/:user_id/tasks/:task_id\u003c/code\u003e みたいに解析を結構頑張らないといけない場合は結構辛い.\u003c/p\u003e\\n\u003cpre\u003e\u003ccode class=\\\"hljs\\\"\u003emux.HandleFunc(\u003cspan class=\\\"hljs-string\\\"\u003e\u0026quot;/users/2/tasks/create\u0026quot;\u003c/span\u003e, createUsers)\\nmux.HandleFunc(\u003cspan class=\\\"hljs-string\\\"\u003e\u0026quot;/users/2/tasks/read/\u0026quot;\u003c/span\u003e, readUsers)\\nmux.HandleFunc(\u003cspan class=\\\"hljs-string\\\"\u003e\u0026quot;/users/2/tasks/update/\u0026quot;\u003c/span\u003e, updateUsers)\\nmux.HandleFunc(\u003cspan class=\\\"hljs-string\\\"\u003e\u0026quot;/users/2/tasks/delete/\u0026quot;\u003c/span\u003e, deleteUsers)\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eこの辺が良さそう.\u003c/p\u003e\\n\u003cul\u003e\\n\u003cli\u003ehttps://github.com/gorilla/mux\u003c/li\u003e\\n\u003cli\u003ehttps://github.com/julienschmidt/httprouter\u003c/li\u003e\\n\u003c/ul\u003e\\n\",\n  \"dir\": \"articles\",\n  \"base\": \"20210723021243.json\",\n  \"ext\": \".json\",\n  \"sourceBase\": \"20210723021243.md\",\n  \"sourceExt\": \".md\"\n}"}},"__N_SSG":true},"page":"/articles/[id]","query":{"id":"20210723021243"},"buildId":"g1tRWIeVJIrrorQy3XYS2","isFallback":false,"gsp":true}</script><script nomodule="" src="/_next/static/chunks/polyfills-7b08e4c67f4f1b892f4b.js"></script><script src="/_next/static/chunks/webpack-189c53927ffd3caf09c3.js" async=""></script><script src="/_next/static/chunks/framework-2f612445bd50b211f15a.js" async=""></script><script src="/_next/static/chunks/main-c8b51cc0a92c3008cd1b.js" async=""></script><script src="/_next/static/chunks/pages/_app-7163558e7d92093a94d2.js" async=""></script><script src="/_next/static/chunks/996-109927db333074874af4.js" async=""></script><script src="/_next/static/chunks/394-1ac6c205f84cbd1b2925.js" async=""></script><script src="/_next/static/chunks/pages/articles/%5Bid%5D-ab036cc92d9ceaf2a9ff.js" async=""></script><script src="/_next/static/g1tRWIeVJIrrorQy3XYS2/_buildManifest.js" async=""></script><script src="/_next/static/g1tRWIeVJIrrorQy3XYS2/_ssgManifest.js" async=""></script></body></html>