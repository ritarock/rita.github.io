{"pageProps":{"body":{"id":"20211022165454","title":"prisma-client-go を試した","body":"\n## prisma のセットアップ\nまずは project の作成から。\n```bash\n$ go mod init backend\n```\n\nclient のインストール。\n```bash\n$ go get github.com/prisma/prisma-client-go\n```\n\nスキーマの作成。\n```bash\n$ npx prisma init\n```\n\n`prisma/schema.prisma` と `.env` (と .gitignore ) が生成される。\n\n\n`.env` ファイルは `DATABASE_URL` を修正。\n```env\n# Environment variables declared in this file are automatically made available to Prisma.\n# See the documentation for more detail: https://pris.ly/d/prisma-schema#using-environment-variables\n\n# Prisma supports the native connection string format for PostgreSQL, MySQL, SQLite, SQL Server and MongoDB (Preview).\n# See the documentation for all the connection string options: https://pris.ly/d/connection-strings\n\nDATABASE_URL=\"mysql://app:password@localhost:3306/app\"\n```\n\n`prisma/schema.prisma` は `client` を `prisma-client-go` に、 `datasource` を `mysql` に修正。\n```schema.prisma\n// This is your Prisma schema file,\n// learn more about it in the docs: https://pris.ly/d/prisma-schema\n\ngenerator client {\n  provider = \"go run github.com/prisma/prisma-client-go\"\n}\n\ndatasource db {\n  provider = \"mysql\"\n  url      = env(\"DATABASE_URL\")\n}\n```\n\n`Task` モデルを定義する。\n```schema.prisma\n// This is your Prisma schema file,\n// learn more about it in the docs: https://pris.ly/d/prisma-schema\n\ngenerator client {\n  provider = \"go run github.com/prisma/prisma-client-go\"\n}\n\ndatasource db {\n  provider = \"mysql\"\n  url      = env(\"DATABASE_URL\")\n}\n\nmodel Task {\n  id String @default(cuid()) @id\n  createdAt DateTime @default(now())\n  updatedAt DateTime @updatedAt\n  title String\n  status Boolean\n  desc String?\n}\n```\n\nprisma クライアントの作成.\n`prisma/db/` が生成される。\n```bash\n$ go run github.com/prisma/prisma-client-go generate\n```\n\nDB にスキーマを反映させる。\n```bash\n$ go run github.com/prisma/prisma-client-go migrate dev --name create_task\n\n~~\n~~\nmigrations/\n  └─ 20211022082219_create_task/\n    └─ migration.sql\n\nYour database is now in sync with your schema.\n```\n\n既にスキーマファイルが存在する場合。\n```bash\ngo run github.com/prisma/prisma-client-go migrate dev\n```\n\n`prisma/migrations/20211022082219_create_task/migration.sql` を見てみる。\n```sql\n-- CreateTable\nCREATE TABLE `Task` (\n    `id` VARCHAR(191) NOT NULL,\n    `createdAt` DATETIME(3) NOT NULL DEFAULT CURRENT_TIMESTAMP(3),\n    `updatedAt` DATETIME(3) NOT NULL,\n    `title` VARCHAR(191) NOT NULL,\n    `status` BOOLEAN NOT NULL,\n    `desc` VARCHAR(191) NULL,\n\n    PRIMARY KEY (`id`)\n) DEFAULT CHARACTER SET utf8mb4 COLLATE utf8mb4_unicode_ci;\n```\n\nテーブルも作成されている。\n```mysql\nmysql> show tables;\n+--------------------+\n| Tables_in_app      |\n+--------------------+\n| _prisma_migrations |\n| Task               |\n+--------------------+\n```\n\n`Comment` モデルを定義し、 `Task` モデルと関連付けを行う。\n```schema.prisma\nmodel Task {\n  id String @default(cuid()) @id\n  createdAt DateTime @default(now())\n  updatedAt DateTime @updatedAt\n  title String\n  status Boolean\n  desc String?\n\n  comments Comment[]\n}\n\nmodel Comment {\n  id String @default(cuid()) @id\n  createdAt DateTime @default(now())\n  updatedAt DateTime @updatedAt\n  content String\n\n  task Task @relation(fields: [taskId], references: [id])\n  taskId String\n```\n\nmigration を行う。\n```bash\n$ go run github.com/prisma/prisma-client-go migrate dev --name add_comment_model\n\n~~\n~~\nmigrations/\n  └─ 20211022083117_add_comment_model/\n    └─ migration.sql\n\nYour database is now in sync with your schema.\n```\n\n`migrations/20211022083117_add_comment_model/migration.sql` を見る。\n```sql\n-- CreateTable\nCREATE TABLE `Comment` (\n    `id` VARCHAR(191) NOT NULL,\n    `createdAt` DATETIME(3) NOT NULL DEFAULT CURRENT_TIMESTAMP(3),\n    `updatedAt` DATETIME(3) NOT NULL,\n    `content` VARCHAR(191) NOT NULL,\n    `taskId` VARCHAR(191) NOT NULL,\n\n    PRIMARY KEY (`id`)\n) DEFAULT CHARACTER SET utf8mb4 COLLATE utf8mb4_unicode_ci;\n\n-- AddForeignKey\nALTER TABLE `Comment` ADD CONSTRAINT `Comment_taskId_fkey` FOREIGN KEY (`taskId`) REFERENCES `Task`(`id`) ON DELETE RESTRICT ON UPDATE CASCADE;\n```\n\n## Prisma Studio を使う\n`localhost:5555` で起動する。\n```bash\n$ npx prisma studio\n```\n![](https://raw.githubusercontent.com/ritarock/my-docs/master/etc/Prisma-Studio.png)\n\n## prisma api syntax\n### 全件取得する\n```go\ntasks, err := client.Task.FindMany().Exec(context.Background())\n```\n\n### クエリで取得する\n```go\ntasks, err := client.Task.FindMany(\n  db.Task.Title.Equals(\"1st task\")\n  // <model>.<field>.<method>.(value) 基本的にこの形式で使う\n).Exec(context.Background())\n```\n\n### 一意なデータを取得する\n`schema.prisma` で `@id` 、 `@unique` でマークされたもののみに使用可能。\n```go\ntask, err := client.Task.FindUnique(\n  db.Task.ID.Equals(\"1234567890\")\n).Exec(context.Background())\n```\n\n### 最初に見つかった 1 件を取得する\n```go\ntask, err := client.Task.FindFirst(\n  db.Task.Title.Equals(\"1st task\")\n).Exec(context.Background())\n```\n\n### スキーマのデータ型によってよしなにできる\n\n- `String Filter`\n```go\ntasks, err := client.Task.FindMany(\n  // Title が \"1st task\" と一致する Task を取得\n  db.Task.Title.Equals(\"1st task\")\n\n  // Title に \"task\" を含む Task を取得\n  // db.Task.Title.Contains(\"task\")\n\n  // Title が \"1st\" から始まる Task を取得\n  // db.Task.Title.StartsWith(\"1st\")\n\n  // Title が \"task\" で終わる Task を取得\n  // db.Task.Title.EndsWith(\"task\")\n).Exec(context.Background())\n```\n\n- `Number Filter`\n```go\n// <Field> が 50 である <Model> を取得\ndb.<Model>.<Field>.Equals(50).Exec(context.Background())\n\n// <Field> が 50 以下の <Model> を取得\ndb.<Model>.<Field>.Lte(50).Exec(context.Background())\n\n// <Field> が 50 未満の <Model> を取得\ndb.<Model>.<Field>.Lt(50).Exec(context.Background())\n\n// <Field> が 50 以上の <Model> を取得\ndb.<Model>.<Field>.Gte(50).Exec(context.Background())\n\n// <Field> が 50 より大きいの <Model> を取得\ndb.<Model>.<Field>.Gte(50).Exec(context.Background())\n```\n\n- `Time Filter`\n```go\ntasks, err := client.Task.FindMany(\n  // 昨日作成された task を取得する\n  db.Task.CreatedAt.Equals(yesterday)\n\n  // 過去 6 時間で作られた task を取得する (createdAt > 6 hours ago)\n  // db.Task.Gt(time.Now().Add(-6 * time.Hour))\n\n  // 過去 6 時間で作られた task を取得する (createdAt >= 6 hours ago)\n  // db.Task.Gte(time.Now().Add(-6 * time.Hour))\n\n  // 昨日作成された task を取得する\n  // db.Task.Lt(time.Now().Truncate(24 * time.Hour))\n\n  // 昨日作成された task を取得する (本日 00:00:00 を含む)\n  // db.Task.Lte(time.Now().Truncate(24 * time.Hour))\n).Exec(context.Background())\n```\n\n### NULL 関連\nnull であるものを取得する。\n```go\ndb.Task.Content.EqualsOptional(nil).Exec(context.Background())\n\ncontent := \"string\"\ndb.Task.Content.EqualsOptional(&content).Exec(context.Background())\n```\n\n### 他にも\n- `Not`\n```go\ndb.Task.Not(\n  db.Task.Title.Equals(\"1st task\")\n).Exec(context.Background())\n```\n\n- `Or`\n```go\ndb.Task.Or(\n  db.Task.Title.Equals(\"1st task\"),\n  db.Task.Desc.Equals(\"new task\")\n).Exec(context.Background())\n```\n\n### 関連付けされたクエリ\ntask の title が \"1st task\" で comment が \"new content\" であるもの task を取得する。\n```go\ntasks, err := client.Task.FindMany(\n  db.Task.Title.Equals(\"1st task\")\n  db.Task.Comments.Some(\n    db.Comment.Content.Equals(\"new content\"),\n  ),\n).Exec(context.Background())\n```\n\n### create\n```go\ncreated, err := client.Task.CreateOne(\n  db.Task.Title.Set(newTask.Title),\n  db.Task.Status.Set(newTask.Status),\n  db.Task.Desc.Set(newTask.Desc),\n).Exec(context.Background())\n```\n\n関連付けのあるデータの場合。\n```go\ncreated, err := client.Comment.CreateOne(\n  db.Comment.Content.Set(newComment.Content),\n  db.Comment.Task.Link(\n    db.Task.ID.Equals(taskId),\n  ),\n).Exec(context.Background())\n```\n\n### update\n```go\nupdated, err := client.Task.FindUnique(\n  db.Task.ID.Equals(taskId),\n).Update(\n  db.Task.Title.Set(newTask.Title),\n  db.Task.Status.Set(newTask.Status),\n  db.Task.Desc.Set(newTask.Desc),\n).Exec(context.Background())\n```\n\n### delete\n```go\n_, err := client.Task.FindUnique(\n  db.Task.ID.Equals(taskId),\n).Delete().Exec(context.Background())\n```\n\n### ソースコード全体\n今回は `github.com/gorilla/mux` を使って API サーバを作った。\n```go\npackage main\n\nimport (\n\t\"backend/prisma/db\"\n\t\"context\"\n\t\"encoding/json\"\n\t\"io\"\n\t\"net/http\"\n\n\t\"github.com/gorilla/mux\"\n)\n\ntype Task struct {\n\tId        string `json:\"id\"`\n\tCreatedAt string `json:\"created_at\"`\n\tUpdatedAt string `json:\"updated_at\"`\n\tTitle     string `json:\"title\"`\n\tStatus    bool   `json:\"status\"`\n\tDesc      string `json:\"string\"`\n}\ntype Comment struct {\n\tId        string `json:\"id\"`\n\tCreatedAt string `json:\"created_at\"`\n\tUpdatedAt string `json:\"updated_at\"`\n\tContent   string `json:\"content\"`\n}\n\nfunc main() {\n\tclient := db.NewClient()\n\tif err := client.Prisma.Connect(); err != nil {\n\t\tpanic(err)\n\t}\n\tdefer func() {\n\t\tif err := client.Prisma.Disconnect(); err != nil {\n\t\t\tpanic(err)\n\t\t}\n\t}()\n\n\trouter := mux.NewRouter()\n\n\trouter.HandleFunc(\"/tasks\", func(w http.ResponseWriter, r *http.Request) {\n\t\tvar newTask Task\n\t\terr := r.ParseForm()\n\t\tif err != nil {\n\t\t\tio.WriteString(w, \"ERROR: create task\")\n\t\t}\n\t\tjson.NewDecoder(r.Body).Decode(&newTask)\n\n\t\tcreated, err := client.Task.CreateOne(\n\t\t\tdb.Task.Title.Set(newTask.Title),\n\t\t\tdb.Task.Status.Set(newTask.Status),\n\t\t\tdb.Task.Desc.Set(newTask.Desc),\n\t\t).Exec(context.Background())\n\t\tif err != nil {\n\t\t\tio.WriteString(w, \"ERROR: create task\")\n\t\t}\n\n\t\tvar response struct {\n\t\t\tCode int    `json:\"code\"`\n\t\t\tData []Task `json:\"data\"`\n\t\t}\n\t\tresponse.Code = 200\n\t\tresponse.Data = append(response.Data, Task{\n\t\t\tId:        created.ID,\n\t\t\tCreatedAt: created.CreatedAt.String(),\n\t\t\tUpdatedAt: created.UpdatedAt.String(),\n\t\t\tTitle:     created.Title,\n\t\t\tStatus:    created.Status,\n\t\t\tDesc: func() string {\n\t\t\t\tdesc, ok := created.Desc()\n\t\t\t\tif !ok {\n\t\t\t\t\tdesc = \"\"\n\t\t\t\t}\n\t\t\t\treturn desc\n\t\t\t}(),\n\t\t})\n\t\tresp, _ := json.Marshal(response)\n\t\tw.Header().Set(\"Content-Type\", \"application/json\")\n\t\tw.Write(resp)\n\t}).Methods(\"POST\")\n\n\trouter.HandleFunc(\"/tasks/{task_id}\", func(w http.ResponseWriter, r *http.Request) {\n\t\tparams := mux.Vars(r)\n\t\ttaskId := params[\"task_id\"]\n\n\t\ttask, err := client.Task.FindUnique(\n\t\t\tdb.Task.ID.Equals(taskId),\n\t\t).Exec(context.Background())\n\t\tif err != nil {\n\t\t\tio.WriteString(w, \"ERROR: read task\")\n\t\t}\n\n\t\tvar response struct {\n\t\t\tCode int    `json:\"code\"`\n\t\t\tData []Task `json:\"data\"`\n\t\t}\n\t\tresponse.Code = 200\n\t\tresponse.Data = append(response.Data, Task{\n\t\t\tId:        task.ID,\n\t\t\tCreatedAt: task.CreatedAt.String(),\n\t\t\tUpdatedAt: task.UpdatedAt.String(),\n\t\t\tTitle:     task.Title,\n\t\t\tStatus:    task.Status,\n\t\t\tDesc: func() string {\n\t\t\t\tdesc, ok := task.Desc()\n\t\t\t\tif !ok {\n\t\t\t\t\tdesc = \"\"\n\t\t\t\t}\n\t\t\t\treturn desc\n\t\t\t}(),\n\t\t})\n\t\tresp, _ := json.Marshal(response)\n\t\tw.Header().Set(\"Content-Type\", \"application/json\")\n\t\tw.Write(resp)\n\t}).Methods(\"GET\")\n\n\trouter.HandleFunc(\"/tasks/{task_id}\", func(w http.ResponseWriter, r *http.Request) {\n\t\tparams := mux.Vars(r)\n\t\ttaskId := params[\"task_id\"]\n\t\tvar newTask Task\n\t\terr := r.ParseForm()\n\t\tif err != nil {\n\t\t\tio.WriteString(w, \"ERROR: update task\")\n\t\t}\n\t\tjson.NewDecoder(r.Body).Decode(&newTask)\n\n\t\tupdated, err := client.Task.FindUnique(\n\t\t\tdb.Task.ID.Equals(taskId),\n\t\t).Update(\n\t\t\tdb.Task.Title.Set(newTask.Title),\n\t\t\tdb.Task.Status.Set(newTask.Status),\n\t\t\tdb.Task.Desc.Set(newTask.Desc),\n\t\t).Exec(context.Background())\n\t\tif err != nil {\n\t\t\tio.WriteString(w, \"ERROR: update task\")\n\t\t}\n\t\tvar response struct {\n\t\t\tCode int    `json:\"code\"`\n\t\t\tData []Task `json:\"data\"`\n\t\t}\n\t\tresponse.Code = 200\n\t\tresponse.Data = append(response.Data, Task{\n\t\t\tId:        updated.ID,\n\t\t\tCreatedAt: updated.CreatedAt.String(),\n\t\t\tUpdatedAt: updated.UpdatedAt.String(),\n\t\t\tTitle:     updated.Title,\n\t\t\tStatus:    updated.Status,\n\t\t\tDesc: func() string {\n\t\t\t\tdesc, ok := updated.Desc()\n\t\t\t\tif !ok {\n\t\t\t\t\tdesc = \"\"\n\t\t\t\t}\n\t\t\t\treturn desc\n\t\t\t}(),\n\t\t})\n\t\tresp, _ := json.Marshal(response)\n\t\tw.Header().Set(\"Content-Type\", \"application/json\")\n\t\tw.Write(resp)\n\t}).Methods(\"POST\")\n\n\trouter.HandleFunc(\"/tasks/{task_id}\", func(w http.ResponseWriter, r *http.Request) {\n\t\tparams := mux.Vars(r)\n\t\ttaskId := params[\"task_id\"]\n\n\t\t_, err := client.Task.FindUnique(\n\t\t\tdb.Task.ID.Equals(taskId),\n\t\t).Delete().Exec(context.Background())\n\t\tif err != nil {\n\t\t\tio.WriteString(w, \"ERROR: delete task\")\n\t\t}\n\n\t\ttasks, err := client.Task.FindMany().Exec(context.Background())\n\t\tif err != nil {\n\t\t\tio.WriteString(w, \"ERROR: read all task\")\n\t\t}\n\t\tvar responseData []Task\n\t\tfor _, task := range tasks {\n\t\t\tresponseData = append(responseData, Task{\n\t\t\t\tId:        task.ID,\n\t\t\t\tCreatedAt: task.CreatedAt.String(),\n\t\t\t\tUpdatedAt: task.UpdatedAt.String(),\n\t\t\t\tTitle:     task.Title,\n\t\t\t\tStatus:    false,\n\t\t\t\tDesc: func() string {\n\t\t\t\t\tdesc, ok := task.Desc()\n\t\t\t\t\tif !ok {\n\t\t\t\t\t\tdesc = \"\"\n\t\t\t\t\t}\n\t\t\t\t\treturn desc\n\t\t\t\t}(),\n\t\t\t})\n\t\t}\n\t\tvar response struct {\n\t\t\tCode int    `json:\"code\"`\n\t\t\tData []Task `json:\"data\"`\n\t\t}\n\t\tresponse.Code = 200\n\t\tresponse.Data = append(response.Data, responseData...)\n\t\tresp, _ := json.Marshal(response)\n\t\tw.Header().Set(\"Content-Type\", \"application/json\")\n\t\tw.Write(resp)\n\t}).Methods(\"DELETE\")\n\n\trouter.HandleFunc(\"/tasks\", func(w http.ResponseWriter, r *http.Request) {\n\t\ttasks, err := client.Task.FindMany().Exec(context.Background())\n\t\tif err != nil {\n\t\t\tio.WriteString(w, \"ERROR: read all task\")\n\t\t}\n\t\tvar responseData []Task\n\t\tfor _, task := range tasks {\n\t\t\tresponseData = append(responseData, Task{\n\t\t\t\tId:        task.ID,\n\t\t\t\tCreatedAt: task.CreatedAt.String(),\n\t\t\t\tUpdatedAt: task.UpdatedAt.String(),\n\t\t\t\tTitle:     task.Title,\n\t\t\t\tStatus:    false,\n\t\t\t\tDesc: func() string {\n\t\t\t\t\tdesc, ok := task.Desc()\n\t\t\t\t\tif !ok {\n\t\t\t\t\t\tdesc = \"\"\n\t\t\t\t\t}\n\t\t\t\t\treturn desc\n\t\t\t\t}(),\n\t\t\t})\n\t\t}\n\t\tvar response struct {\n\t\t\tCode int    `json:\"code\"`\n\t\t\tData []Task `json:\"data\"`\n\t\t}\n\t\tresponse.Code = 200\n\t\tresponse.Data = append(response.Data, responseData...)\n\t\tresp, _ := json.Marshal(response)\n\t\tw.Header().Set(\"Content-Type\", \"application/json\")\n\t\tw.Write(resp)\n\t}).Methods(\"GET\")\n\n\trouter.HandleFunc(\"/tasks/{task_id}/comments\", func(w http.ResponseWriter, r *http.Request) {\n\t\tparams := mux.Vars(r)\n\t\ttaskId := params[\"task_id\"]\n\t\tvar newComment Comment\n\t\terr := r.ParseForm()\n\t\tif err != nil {\n\t\t\tio.WriteString(w, \"ERROR: create comment\")\n\t\t}\n\t\tjson.NewDecoder(r.Body).Decode(&newComment)\n\n\t\tcreated, err := client.Comment.CreateOne(\n\t\t\tdb.Comment.Content.Set(newComment.Content),\n\t\t\tdb.Comment.Task.Link(\n\t\t\t\tdb.Task.ID.Equals(taskId),\n\t\t\t),\n\t\t).Exec(context.Background())\n\t\tif err != nil {\n\t\t\tio.WriteString(w, \"ERROR: create comment\")\n\t\t}\n\t\tvar response struct {\n\t\t\tCode int       `json:\"code\"`\n\t\t\tData []Comment `json:\"data\"`\n\t\t}\n\t\tresponse.Code = 200\n\t\tresponse.Data = append(response.Data, Comment{\n\t\t\tId:        created.ID,\n\t\t\tCreatedAt: created.CreatedAt.String(),\n\t\t\tUpdatedAt: created.UpdatedAt.String(),\n\t\t\tContent:   created.Content,\n\t\t})\n\t\tresp, _ := json.Marshal(response)\n\t\tw.Header().Set(\"Content-Type\", \"application/json\")\n\t\tw.Write(resp)\n\t}).Methods(\"POST\")\n\n\trouter.HandleFunc(\"/tasks/{task_id}/comments\", func(w http.ResponseWriter, r *http.Request) {\n\t\tparams := mux.Vars(r)\n\t\ttaskId := params[\"task_id\"]\n\t\tcomments, err := client.Comment.FindMany(\n\t\t\tdb.Comment.TaskID.Equals(taskId),\n\t\t).Exec(context.Background())\n\t\tif err != nil {\n\t\t\tio.WriteString(w, \"ERROR: read comment\")\n\t\t}\n\t\tvar responseData []Comment\n\t\tfor _, comment := range comments {\n\t\t\tresponseData = append(responseData, Comment{\n\t\t\t\tId:        comment.ID,\n\t\t\t\tCreatedAt: comment.CreatedAt.String(),\n\t\t\t\tUpdatedAt: comment.UpdatedAt.String(),\n\t\t\t\tContent:   comment.Content,\n\t\t\t})\n\t\t}\n\t\tvar response struct {\n\t\t\tCode int       `json:\"code\"`\n\t\t\tData []Comment `json:\"data\"`\n\t\t}\n\t\tresponse.Code = 200\n\t\tresponse.Data = append(response.Data, responseData...)\n\t\tresp, _ := json.Marshal(response)\n\t\tw.Header().Set(\"Content-Type\", \"application/json\")\n\t\tw.Write(resp)\n\t}).Methods(\"GET\")\n\n\trouter.HandleFunc(\"/tasks/{task_id}/comments/{comment_id}\", func(w http.ResponseWriter, r *http.Request) {\n\t\tparams := mux.Vars(r)\n\t\tcommentId := params[\"comment_id\"]\n\t\tvar newComment Comment\n\t\terr := r.ParseForm()\n\t\tif err != nil {\n\t\t\tio.WriteString(w, \"ERROR: update comment\")\n\t\t}\n\t\tjson.NewDecoder(r.Body).Decode(&newComment)\n\n\t\tupdated, err := client.Comment.FindUnique(\n\t\t\tdb.Comment.ID.Equals(commentId),\n\t\t).Update(\n\t\t\tdb.Comment.Content.Set(newComment.Content),\n\t\t).Exec(context.Background())\n\t\tif err != nil {\n\t\t\tio.WriteString(w, \"update error\")\n\t\t}\n\t\tvar response struct {\n\t\t\tCode int       `json:\"code\"`\n\t\t\tData []Comment `json:\"comment\"`\n\t\t}\n\t\tresponse.Code = 200\n\t\tresponse.Data = append(response.Data, Comment{\n\t\t\tId:        updated.ID,\n\t\t\tCreatedAt: updated.CreatedAt.String(),\n\t\t\tUpdatedAt: updated.UpdatedAt.String(),\n\t\t\tContent:   updated.Content,\n\t\t})\n\t\tresp, _ := json.Marshal(response)\n\t\tw.Header().Set(\"Content-Type\", \"application/json\")\n\t\tw.Write(resp)\n\t}).Methods(\"POST\")\n\n\trouter.HandleFunc(\"/tasks/{task_id}/comments/{comment_id}\", func(w http.ResponseWriter, r *http.Request) {\n\t\tparams := mux.Vars(r)\n\t\ttaskId := params[\"task_id\"]\n\t\tcommentId := params[\"comment_id\"]\n\n\t\t_, err := client.Comment.FindUnique(\n\t\t\tdb.Comment.ID.Equals(commentId),\n\t\t).Delete().Exec(context.Background())\n\t\tif err != nil {\n\t\t\tio.WriteString(w, \"ERROR: delete comment\")\n\t\t}\n\n\t\tcomments, err := client.Comment.FindMany(\n\t\t\tdb.Comment.TaskID.Equals(taskId),\n\t\t).Exec(context.Background())\n\t\tif err != nil {\n\t\t\tio.WriteString(w, \"ERROR: read all comment\")\n\t\t}\n\t\tvar responseData []Comment\n\t\tfor _, comment := range comments {\n\t\t\tresponseData = append(responseData, Comment{\n\t\t\t\tId:        comment.ID,\n\t\t\t\tCreatedAt: comment.CreatedAt.String(),\n\t\t\t\tUpdatedAt: comment.UpdatedAt.String(),\n\t\t\t\tContent:   comment.Content,\n\t\t\t})\n\t\t}\n\t\tvar response struct {\n\t\t\tCode int       `json:\"code\"`\n\t\t\tData []Comment `json:\"data\"`\n\t\t}\n\t\tresponse.Code = 200\n\t\tresponse.Data = append(response.Data, responseData...)\n\t\tresp, _ := json.Marshal(response)\n\t\tw.Header().Set(\"Content-Type\", \"application/json\")\n\t\tw.Write(resp)\n\t}).Methods(\"DELETE\")\n\n\tserver := http.Server{\n\t\tAddr:    \"0.0.0.0:8080\",\n\t\tHandler: router,\n\t}\n\tserver.ListenAndServe()\n}\n```\n"}},"__N_SSG":true}