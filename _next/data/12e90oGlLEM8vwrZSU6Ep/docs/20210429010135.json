{"pageProps":{"contents":{"id":"20210429010135","title":"Golang の goroutine / channel とか","body":"\n## goroutine\ngoroutine は軽量なスレッド。\n```go\ngo f(x, y)\n```\nと書くだけ。\n\n```go\npackage main\n\nimport (\n\t\"fmt\"\n\t\"time\"\n)\n\nfunc say(s string) {\n\tfor i := 0; i < 5; i++ {\n\t\ttime.Sleep(100 * time.Millisecond)\n\t\tfmt.Println(s)\n\t}\n}\n\nfunc main() {\n\tgo say(\"hello\")\n\tsay(\"world\")\n}\n\n// hello\n// world\n// world\n// hello\n// hello\n// world\n// hello\n// world\n// world\n// hello\n```\n\n## channel\nchannel 型は `<-` を用いて値の送受信を行う。\n```go\nch <- v // v をチャネル ch に送信する\nv := <- ch // チャネル ch から変数を v に割り当てる\n```\n\nチャネルは `make` で作る。\n```go\nch := make(chan int)\n```\n通常、片方の準備ができるまで送受信はブロックされる。\n\n```go\npackage main\n\nimport \"fmt\"\n\nfunc sum(s []int, c chan int) {\n\tsum := 0\n\tfor _, v := range s {\n\t\tsum += v\n\t}\n\tc <- sum\n}\n\nfunc main() {\n\ts := []int{1, 2, 3, 4, 5, 6, 7, 8, 9, 10}\n\tc := make(chan int)\n\n\tgo sum(s[:len(s)/2], c)\n\tgo sum(s[len(s)/2:], c)\n\tgo sum(s, c)\n\n\tx, y := <-c, <-c\n\tz := <-c\n\n\tfmt.Println(x, y, z)\n}\n\n// 55 15 40\n// 55 40 15\n// 処理終わった順かな？\n```\n\n### バッファ\nチャネルはバッファとして使える。 make の 2 つ目の引数にバッファの長さを指定できる。\n```go\nch := make(chan int, 10)\n```\n\nバッファ数を超えると deadlock になる。\n```go\npackage main\n\nimport \"fmt\"\n\nfunc main() {\n\tch := make(chan bool, 2)\n\tch <- true\n\tch <- true\n\tv := <-ch\n\tch <- true\n\t// ch <- true // この行を入れると deadlock\n\n\tfmt.Println(len(ch))\n\tfmt.Println(<-ch)\n\tfmt.Println(<-ch)\n\tfmt.Println(v)\n\tfmt.Println(len(ch))\n}\n\n// 2\n// true\n// true\n// true\n// 0\n```\n\n### close\n送信側はチャネルを `close` できる。\n受信側はチャネルを `close` しているか確認できる。\n受信する値はなく、かつチャネルが閉じているなら `ok` は `false` になる。\n```go\nv, ok := <- ch\n```\n\nループのときはチャネルを使うとチャネルが閉じるまで値を受信し続ける。\n```go\npackage main\n\nimport \"fmt\"\n\nfunc fibonacci(n int, c chan int) {\n\tx, y := 0, 1\n\tfor i := 0; i < n; i++ {\n\t\tc <- x\n\t\tx, y = y, x+y\n\t}\n\tclose(c)\n}\n\nfunc main() {\n\tc := make(chan int, 10)\n\tgo fibonacci(cap(c), c)\n\tfor i := range c {\n\t\tfmt.Println(i)\n\t}\n}\n\n// 0\n// 1\n// 1\n// 2\n// 3\n// 5\n// 8\n// 13\n// 21\n// 34\n```\n\n## select\n`select` は goroutine を複数の通信操作で待たせる。\ncase の準備ができるまでブロックする。複数の case が準備できている場合、 case はランダムに実行される。\n```go\npackage main\n\nimport \"fmt\"\n\nfunc fibonacci(c, quit chan int) {\n\tx, y := 0, 1\n\tfor {\n\t\tselect {\n\t\tcase c <- x:\n\t\t\tx, y = y, x+y\n\t\tcase <-quit:\n\t\t\tfmt.Println(\"quit\")\n\t\t\treturn\n\t\t}\n\t}\n}\n\nfunc main() {\n\tc := make(chan int)\n\tquit := make(chan int)\n\n\tgo func() {\n\t\tfor i := 0; i < 10; i++ {\n\t\t\tfmt.Println(<-c)\n\t\t}\n\t\tquit <- 0\n\t}()\n\tfibonacci(c, quit)\n}\n\n// 0\n// 1\n// 1\n// 2\n// 3\n// 5\n// 8\n// 13\n// 21\n// 34\n// quit\n```\n\n### default\nブロックせずに送受信したいときには default を使う。\n```go\npackage main\n\nimport (\n\t\"fmt\"\n\t\"time\"\n)\n\nfunc main() {\n\ttick := time.Tick(100 * time.Millisecond)\n\tboom := time.Tick(500 * time.Millisecond)\n\n\tfor {\n\t\tselect {\n\t\tcase <-tick:\n\t\t\tfmt.Println(\"tick\")\n\t\tcase <-boom:\n\t\t\tfmt.Println(\"boom\")\n\t\t\treturn\n\t\tdefault:\n\t\t\tfmt.Println(\"   .\")\n\t\t\ttime.Sleep(50 * time.Millisecond)\n\t\t}\n\t}\n}\n\n//    .\n//    .\n// tick\n//    .\n//    .\n// tick\n//    .\n//    .\n// tick\n//    .\n//    .\n// tick\n//    .\n//    .\n// boom\n```\n\n## sync.Mutex\nコンフリクトを避け、 1 度に 1 つの goroutine だけが変数にアクセスできる。\nGolang の標準パッケージは,排他制御を `sync.Mutex` と `Lock` 、 `Unlock` で提供している。\n```go\npackage main\n\nimport (\n\t\"fmt\"\n\t\"sync\"\n\t\"time\"\n)\n\ntype SafeCounter struct {\n\tmu sync.Mutex\n\tv  map[string]int\n}\n\nfunc (c *SafeCounter) Inc(key string) {\n\tc.mu.Lock()\n\tc.v[key]++\n\tc.mu.Unlock()\n}\n\nfunc (c *SafeCounter) Value(key string) int {\n\tc.mu.Lock()\n\tdefer c.mu.Unlock()\n\treturn c.v[key]\n}\n\nfunc main() {\n\tc := SafeCounter{\n\t\tv: make(map[string]int),\n\t}\n\n\tfor i := 0; i < 1000; i++ {\n\t\tgo c.Inc(\"somekey\")\n\t}\n\ttime.Sleep(time.Second)\n\tfmt.Println(c.Value(\"somekey\"))\n}\n\n// 1000\n```\n"}},"__N_SSG":true}