{"pageProps":{"data":{"id":"20210723021243","fileContents":"{\n  \"title\": \"Golang の http/net について調べた\",\n  \"date\": 20210723021243,\n  \"tags\": [\n    \"golang\"\n  ],\n  \"bodyContent\": \"## サーバ\\n何もしないサーバを起動。\\n```go\\npackage main\\n\\nimport \\\"net/http\\\"\\n\\nfunc main() {\\n\\thttp.ListenAndServe(\\\"\\\", nil)\\n}\\n```\\n\\n***ListenAndServe*** は ネットワークアドレスとハンドラを引数で受け取る。ハンドラが nil の場合は ***DefaultServerMux*** が使われる。\\n\\nServer の構造体はこんな感じ。\\n```go\\ntype Server struct {\\n\\tAddr string\\n\\tHandler Handler\\n\\tTLSConfig *tls.Config\\n\\tReadTimeout time.Duration\\n\\tReadHeaderTimeout time.Duration\\n\\tWriteTimeout time.Duration\\n\\tIdleTimeout time.Duration\\n\\tMaxHeaderBytes int\\n\\tTLSNextProto map[string]func(*Server, *tls.Conn, Handler)\\n\\tConnState func(net.Conn, ConnState)\\n\\tErrorLog *log.Logger\\n\\tBaseContext func(net.Listener) context.Context\\n\\tConnContext func(ctx context.Context, c net.Conn) context.Context\\n\\tinShutdown atomicBool\\n\\tdisableKeepAlives int32\\n\\tnextProtoOnce     sync.Once\\n\\tnextProtoErr      error\\n\\tmu         sync.Mutex\\n\\tlisteners  map[*net.Listener]struct{}\\n\\tactiveConn map[*conn]struct{}\\n\\tdoneChan   chan struct{}\\n\\tonShutdown []func()\\n}\\n```\\n\\n設定を変更する場合は Server の構造体に値を指定する。\\n```go\\nfunc main() {\\n\\tserver := http.Server{\\n\\t\\tAddr:    \\\"0.0.0.0:8080\\\",\\n\\t\\tHandler: nil,\\n\\t}\\n\\tserver.ListenAndServe()\\n```\\n\\n### ハンドラとハンドラ関数\\nハンドラがない場合すべてのリクエストで 404 を返す。\\n\\nハンドラとは、 ***ServerHTTP メソッド*** を持ったインターフェースのことを指す。\\nこのメソッドは、***インターフェース HTTPResponseWriter*** と ***構造体 Request のポインタ*** の 2 つの引数を取る。\\nつまり、 ***ServerHTTP(http.ResponseWriter, \\\\*http.Request)*** をもつインターフェースがハンドラになる。\\n```go\\ntype HelloHandler struct{}\\n\\nfunc (h *HelloHandler) ServeHTTP(writer http.ResponseWriter, request *http.Request) {\\n\\tfmt.Fprintf(writer, \\\"hello\\\")\\n}\\n\\nfunc main() {\\n\\thelloHandler := new(HelloHandler)\\n\\tserver := http.Server{\\n\\t\\tAddr:    \\\"0.0.0.0:8080\\\",\\n\\t\\tHandler: helloHandler,\\n\\t}\\n\\tserver.ListenAndServe()\\n}\\n```\\n\\nこの状態だと、すべてのアクセスが 1 つのハンドラに行く。\\n\\n実際は URL ごとに異なるハンドラで処理する必要があるため Handler フィールドに値を指定しない (デフォルトで DefaultServerMux を使う) 。\\n\\n```go\\ntype HelloHandler struct{}\\ntype WorldHandler struct{}\\n\\nfunc (h *HelloHandler) ServeHTTP(writer http.ResponseWriter, request *http.Request) {\\n\\tfmt.Fprintf(writer, \\\"hello\\\")\\n}\\nfunc (w *WorldHandler) ServeHTTP(writer http.ResponseWriter, request *http.Request) {\\n\\tfmt.Fprintf(writer, \\\"world\\\")\\n}\\n\\nfunc main() {\\n\\thelloHandler := new(HelloHandler)\\n\\tworldHandler := new(WorldHandler)\\n\\tserver := http.Server{\\n\\t\\tAddr: \\\"0.0.0.0:8080\\\",\\n\\t}\\n\\thttp.Handle(\\\"/hello\\\", helloHandler)\\n\\thttp.Handle(\\\"/world\\\", worldHandler)\\n\\tserver.ListenAndServe()\\n}\\n```\\n\\n***http.Handle*** は実際には DefaultServeMux の Handle メソッドを呼び出している。\\n\\n```go\\nfunc Handle(pattern string, handler Handler) { DefaultServeMux.Handle(pattern, handler) }\\n```\\n\\nハンドラとは、 ***ServerHTTP(http.ResponseWriter, *http.Request)*** をもつインターフェース のこと。\\nハンドラ関数とは、ハンドラのように振る舞う関数。リクエストのポインタを受け取ることができる。\\n\\n```go\\npackage main\\n\\nimport (\\n\\t\\\"fmt\\\"\\n\\t\\\"net/http\\\"\\n)\\n\\ntype HelloHandler struct{}\\ntype WorldHandler struct{}\\n\\nfunc (h *HelloHandler) ServeHTTP(writer http.ResponseWriter, request *http.Request) {\\n\\tfmt.Fprintf(writer, \\\"hello\\\")\\n}\\nfunc (w *WorldHandler) ServeHTTP(writer http.ResponseWriter, request *http.Request) {\\n\\tfmt.Fprintf(writer, \\\"world\\\")\\n}\\n\\nfunc hello(writer http.ResponseWriter, request *http.Request) {\\n\\tfmt.Fprintf(writer, \\\"hello\\\")\\n}\\nfunc world(writer http.ResponseWriter, request *http.Request) {\\n\\tfmt.Fprintf(writer, \\\"world\\\")\\n}\\n\\nfunc main() {\\n\\thelloHandler := new(HelloHandler)\\n\\tworldHandler := new(WorldHandler)\\n\\tserver := http.Server{\\n\\t\\tAddr: \\\"0.0.0.0:8080\\\",\\n\\t}\\n\\thttp.Handle(\\\"/hello\\\", helloHandler)\\n\\thttp.Handle(\\\"/world\\\", worldHandler)\\n\\thttp.HandleFunc(\\\"/hello2\\\", hello)\\n\\thttp.HandleFunc(\\\"/world2\\\", world)\\n\\tserver.ListenAndServe()\\n}\\n```\\n\\n### 何が違うのか\\nやってることは ***DefaultServeMux.Handle(pattern, handler)** なので同じ。\\n既存のインターフェースがある場合は、 ***ServeHTTP*** メソッドを追加するだけでハンドラになるからそういった場合は、***http.Handle*** のほうが手軽。\\n\\n```go\\nfunc Handle(pattern string, handler Handler) { DefaultServeMux.Handle(pattern, handler) }\\n\\nfunc HandleFunc(pattern string, handler func(ResponseWriter, *Request)) {\\n\\tDefaultServeMux.HandleFunc(pattern, handler)\\n}\\n\\nfunc (mux *ServeMux) HandleFunc(pattern string, handler func(ResponseWriter, *Request)) {\\n\\tif handler == nil {\\n\\t\\tpanic(\\\"http: nil handler\\\")\\n\\t}\\n\\tmux.Handle(pattern, HandlerFunc(handler))\\n}\\n```\\n\\n## サードパーティー製のマルチプレクサ\\n標準でも特に辛くない。 ***request.Method*** でメソッドも取得できるのでかなり使い勝手もいい。\\n```go\\nmux.HandleFunc(\\\"/users/create\\\", createUsers)\\nmux.HandleFunc(\\\"/users/read/\\\", readUsers)\\nmux.HandleFunc(\\\"/users/update/\\\", updateUsers)\\nmux.HandleFunc(\\\"/users/delete/\\\", deleteUsers)\\n\\nfunc readerUsers(writer http.ResponseWriter, request *http.Request) {\\n\\tsub := strings.TrimPrefix(request.URL.Path, \\\"/users/read/\\\")\\n\\tuserId, err := strconv.Atoi(sub) // これで /users/read/:id の id を取得できる\\n}\\n```\\n\\n下記のような、 ***/users/:user_id/tasks/:task_id*** みたいに解析を結構頑張らないといけない場合は結構辛い。\\n```go\\nmux.HandleFunc(\\\"/users/2/tasks/create\\\", createUsers)\\nmux.HandleFunc(\\\"/users/2/tasks/read/\\\", readUsers)\\nmux.HandleFunc(\\\"/users/2/tasks/update/\\\", updateUsers)\\nmux.HandleFunc(\\\"/users/2/tasks/delete/\\\", deleteUsers)\\n```\\n\\nこの辺が良さそう。\\n- https://github.com/gorilla/mux\\n- https://github.com/julienschmidt/httprouter\",\n  \"bodyHtml\": \"<h2>サーバ</h2>\\n<p>何もしないサーバを起動。</p>\\n<pre><code class=\\\"hljs\\\"><span class=\\\"hljs-keyword\\\">package</span> main\\n\\n<span class=\\\"hljs-keyword\\\">import</span> <span class=\\\"hljs-string\\\">&quot;net/http&quot;</span>\\n\\n<span class=\\\"hljs-function\\\"><span class=\\\"hljs-keyword\\\">func</span> <span class=\\\"hljs-title\\\">main</span><span class=\\\"hljs-params\\\">()</span></span> {\\n\\thttp.ListenAndServe(<span class=\\\"hljs-string\\\">&quot;&quot;</span>, <span class=\\\"hljs-literal\\\">nil</span>)\\n}</code></pre><p><em><strong>ListenAndServe</strong></em> は ネットワークアドレスとハンドラを引数で受け取る。ハンドラが nil の場合は <em><strong>DefaultServerMux</strong></em> が使われる。</p>\\n<p>Server の構造体はこんな感じ。</p>\\n<pre><code class=\\\"hljs\\\"><span class=\\\"hljs-keyword\\\">type</span> Server <span class=\\\"hljs-keyword\\\">struct</span> {\\n\\tAddr <span class=\\\"hljs-keyword\\\">string</span>\\n\\tHandler Handler\\n\\tTLSConfig *tls.Config\\n\\tReadTimeout time.Duration\\n\\tReadHeaderTimeout time.Duration\\n\\tWriteTimeout time.Duration\\n\\tIdleTimeout time.Duration\\n\\tMaxHeaderBytes <span class=\\\"hljs-keyword\\\">int</span>\\n\\tTLSNextProto <span class=\\\"hljs-keyword\\\">map</span>[<span class=\\\"hljs-keyword\\\">string</span>]<span class=\\\"hljs-function\\\"><span class=\\\"hljs-keyword\\\">func</span><span class=\\\"hljs-params\\\">(*Server, *tls.Conn, Handler)</span></span>\\n\\tConnState <span class=\\\"hljs-function\\\"><span class=\\\"hljs-keyword\\\">func</span><span class=\\\"hljs-params\\\">(net.Conn, ConnState)</span></span>\\n\\tErrorLog *log.Logger\\n\\tBaseContext <span class=\\\"hljs-function\\\"><span class=\\\"hljs-keyword\\\">func</span><span class=\\\"hljs-params\\\">(net.Listener)</span> <span class=\\\"hljs-title\\\">context</span>.<span class=\\\"hljs-title\\\">Context</span></span>\\n\\tConnContext <span class=\\\"hljs-function\\\"><span class=\\\"hljs-keyword\\\">func</span><span class=\\\"hljs-params\\\">(ctx context.Context, c net.Conn)</span> <span class=\\\"hljs-title\\\">context</span>.<span class=\\\"hljs-title\\\">Context</span></span>\\n\\tinShutdown atomicBool\\n\\tdisableKeepAlives <span class=\\\"hljs-keyword\\\">int32</span>\\n\\tnextProtoOnce     sync.Once\\n\\tnextProtoErr      error\\n\\tmu         sync.Mutex\\n\\tlisteners  <span class=\\\"hljs-keyword\\\">map</span>[*net.Listener]<span class=\\\"hljs-keyword\\\">struct</span>{}\\n\\tactiveConn <span class=\\\"hljs-keyword\\\">map</span>[*conn]<span class=\\\"hljs-keyword\\\">struct</span>{}\\n\\tdoneChan   <span class=\\\"hljs-keyword\\\">chan</span> <span class=\\\"hljs-keyword\\\">struct</span>{}\\n\\tonShutdown []<span class=\\\"hljs-function\\\"><span class=\\\"hljs-keyword\\\">func</span><span class=\\\"hljs-params\\\">()</span></span>\\n}</code></pre><p>設定を変更する場合は Server の構造体に値を指定する。</p>\\n<pre><code class=\\\"hljs\\\"><span class=\\\"hljs-function\\\"><span class=\\\"hljs-keyword\\\">func</span> <span class=\\\"hljs-title\\\">main</span><span class=\\\"hljs-params\\\">()</span></span> {\\n\\tserver := http.Server{\\n\\t\\tAddr:    <span class=\\\"hljs-string\\\">&quot;0.0.0.0:8080&quot;</span>,\\n\\t\\tHandler: <span class=\\\"hljs-literal\\\">nil</span>,\\n\\t}\\n\\tserver.ListenAndServe()</code></pre><h3>ハンドラとハンドラ関数</h3>\\n<p>ハンドラがない場合すべてのリクエストで 404 を返す。</p>\\n<p>ハンドラとは、 <em><strong>ServerHTTP メソッド</strong></em> を持ったインターフェースのことを指す。\\nこのメソッドは、<em><strong>インターフェース HTTPResponseWriter</strong></em> と <em><strong>構造体 Request のポインタ</strong></em> の 2 つの引数を取る。\\nつまり、 <em><strong>ServerHTTP(http.ResponseWriter, *http.Request)</strong></em> をもつインターフェースがハンドラになる。</p>\\n<pre><code class=\\\"hljs\\\"><span class=\\\"hljs-keyword\\\">type</span> HelloHandler <span class=\\\"hljs-keyword\\\">struct</span>{}\\n\\n<span class=\\\"hljs-function\\\"><span class=\\\"hljs-keyword\\\">func</span> <span class=\\\"hljs-params\\\">(h *HelloHandler)</span> <span class=\\\"hljs-title\\\">ServeHTTP</span><span class=\\\"hljs-params\\\">(writer http.ResponseWriter, request *http.Request)</span></span> {\\n\\tfmt.Fprintf(writer, <span class=\\\"hljs-string\\\">&quot;hello&quot;</span>)\\n}\\n\\n<span class=\\\"hljs-function\\\"><span class=\\\"hljs-keyword\\\">func</span> <span class=\\\"hljs-title\\\">main</span><span class=\\\"hljs-params\\\">()</span></span> {\\n\\thelloHandler := <span class=\\\"hljs-built_in\\\">new</span>(HelloHandler)\\n\\tserver := http.Server{\\n\\t\\tAddr:    <span class=\\\"hljs-string\\\">&quot;0.0.0.0:8080&quot;</span>,\\n\\t\\tHandler: helloHandler,\\n\\t}\\n\\tserver.ListenAndServe()\\n}</code></pre><p>この状態だと、すべてのアクセスが 1 つのハンドラに行く。</p>\\n<p>実際は URL ごとに異なるハンドラで処理する必要があるため Handler フィールドに値を指定しない (デフォルトで DefaultServerMux を使う) 。</p>\\n<pre><code class=\\\"hljs\\\"><span class=\\\"hljs-keyword\\\">type</span> HelloHandler <span class=\\\"hljs-keyword\\\">struct</span>{}\\n<span class=\\\"hljs-keyword\\\">type</span> WorldHandler <span class=\\\"hljs-keyword\\\">struct</span>{}\\n\\n<span class=\\\"hljs-function\\\"><span class=\\\"hljs-keyword\\\">func</span> <span class=\\\"hljs-params\\\">(h *HelloHandler)</span> <span class=\\\"hljs-title\\\">ServeHTTP</span><span class=\\\"hljs-params\\\">(writer http.ResponseWriter, request *http.Request)</span></span> {\\n\\tfmt.Fprintf(writer, <span class=\\\"hljs-string\\\">&quot;hello&quot;</span>)\\n}\\n<span class=\\\"hljs-function\\\"><span class=\\\"hljs-keyword\\\">func</span> <span class=\\\"hljs-params\\\">(w *WorldHandler)</span> <span class=\\\"hljs-title\\\">ServeHTTP</span><span class=\\\"hljs-params\\\">(writer http.ResponseWriter, request *http.Request)</span></span> {\\n\\tfmt.Fprintf(writer, <span class=\\\"hljs-string\\\">&quot;world&quot;</span>)\\n}\\n\\n<span class=\\\"hljs-function\\\"><span class=\\\"hljs-keyword\\\">func</span> <span class=\\\"hljs-title\\\">main</span><span class=\\\"hljs-params\\\">()</span></span> {\\n\\thelloHandler := <span class=\\\"hljs-built_in\\\">new</span>(HelloHandler)\\n\\tworldHandler := <span class=\\\"hljs-built_in\\\">new</span>(WorldHandler)\\n\\tserver := http.Server{\\n\\t\\tAddr: <span class=\\\"hljs-string\\\">&quot;0.0.0.0:8080&quot;</span>,\\n\\t}\\n\\thttp.Handle(<span class=\\\"hljs-string\\\">&quot;/hello&quot;</span>, helloHandler)\\n\\thttp.Handle(<span class=\\\"hljs-string\\\">&quot;/world&quot;</span>, worldHandler)\\n\\tserver.ListenAndServe()\\n}</code></pre><p><em><strong>http.Handle</strong></em> は実際には DefaultServeMux の Handle メソッドを呼び出している。</p>\\n<pre><code class=\\\"hljs\\\"><span class=\\\"hljs-function\\\"><span class=\\\"hljs-keyword\\\">func</span> <span class=\\\"hljs-title\\\">Handle</span><span class=\\\"hljs-params\\\">(pattern <span class=\\\"hljs-keyword\\\">string</span>, handler Handler)</span></span> { DefaultServeMux.Handle(pattern, handler) }</code></pre><p>ハンドラとは、 *<strong>ServerHTTP(http.ResponseWriter, <em>http.Request)</em></strong> をもつインターフェース のこと。\\nハンドラ関数とは、ハンドラのように振る舞う関数。リクエストのポインタを受け取ることができる。</p>\\n<pre><code class=\\\"hljs\\\"><span class=\\\"hljs-keyword\\\">package</span> main\\n\\n<span class=\\\"hljs-keyword\\\">import</span> (\\n\\t<span class=\\\"hljs-string\\\">&quot;fmt&quot;</span>\\n\\t<span class=\\\"hljs-string\\\">&quot;net/http&quot;</span>\\n)\\n\\n<span class=\\\"hljs-keyword\\\">type</span> HelloHandler <span class=\\\"hljs-keyword\\\">struct</span>{}\\n<span class=\\\"hljs-keyword\\\">type</span> WorldHandler <span class=\\\"hljs-keyword\\\">struct</span>{}\\n\\n<span class=\\\"hljs-function\\\"><span class=\\\"hljs-keyword\\\">func</span> <span class=\\\"hljs-params\\\">(h *HelloHandler)</span> <span class=\\\"hljs-title\\\">ServeHTTP</span><span class=\\\"hljs-params\\\">(writer http.ResponseWriter, request *http.Request)</span></span> {\\n\\tfmt.Fprintf(writer, <span class=\\\"hljs-string\\\">&quot;hello&quot;</span>)\\n}\\n<span class=\\\"hljs-function\\\"><span class=\\\"hljs-keyword\\\">func</span> <span class=\\\"hljs-params\\\">(w *WorldHandler)</span> <span class=\\\"hljs-title\\\">ServeHTTP</span><span class=\\\"hljs-params\\\">(writer http.ResponseWriter, request *http.Request)</span></span> {\\n\\tfmt.Fprintf(writer, <span class=\\\"hljs-string\\\">&quot;world&quot;</span>)\\n}\\n\\n<span class=\\\"hljs-function\\\"><span class=\\\"hljs-keyword\\\">func</span> <span class=\\\"hljs-title\\\">hello</span><span class=\\\"hljs-params\\\">(writer http.ResponseWriter, request *http.Request)</span></span> {\\n\\tfmt.Fprintf(writer, <span class=\\\"hljs-string\\\">&quot;hello&quot;</span>)\\n}\\n<span class=\\\"hljs-function\\\"><span class=\\\"hljs-keyword\\\">func</span> <span class=\\\"hljs-title\\\">world</span><span class=\\\"hljs-params\\\">(writer http.ResponseWriter, request *http.Request)</span></span> {\\n\\tfmt.Fprintf(writer, <span class=\\\"hljs-string\\\">&quot;world&quot;</span>)\\n}\\n\\n<span class=\\\"hljs-function\\\"><span class=\\\"hljs-keyword\\\">func</span> <span class=\\\"hljs-title\\\">main</span><span class=\\\"hljs-params\\\">()</span></span> {\\n\\thelloHandler := <span class=\\\"hljs-built_in\\\">new</span>(HelloHandler)\\n\\tworldHandler := <span class=\\\"hljs-built_in\\\">new</span>(WorldHandler)\\n\\tserver := http.Server{\\n\\t\\tAddr: <span class=\\\"hljs-string\\\">&quot;0.0.0.0:8080&quot;</span>,\\n\\t}\\n\\thttp.Handle(<span class=\\\"hljs-string\\\">&quot;/hello&quot;</span>, helloHandler)\\n\\thttp.Handle(<span class=\\\"hljs-string\\\">&quot;/world&quot;</span>, worldHandler)\\n\\thttp.HandleFunc(<span class=\\\"hljs-string\\\">&quot;/hello2&quot;</span>, hello)\\n\\thttp.HandleFunc(<span class=\\\"hljs-string\\\">&quot;/world2&quot;</span>, world)\\n\\tserver.ListenAndServe()\\n}</code></pre><h3>何が違うのか</h3>\\n<p>やってることは *<strong>DefaultServeMux.Handle(pattern, handler)</strong> なので同じ。\\n既存のインターフェースがある場合は、 <em><strong>ServeHTTP</strong></em> メソッドを追加するだけでハンドラになるからそういった場合は、<em><strong>http.Handle</strong></em> のほうが手軽。</p>\\n<pre><code class=\\\"hljs\\\"><span class=\\\"hljs-function\\\"><span class=\\\"hljs-keyword\\\">func</span> <span class=\\\"hljs-title\\\">Handle</span><span class=\\\"hljs-params\\\">(pattern <span class=\\\"hljs-keyword\\\">string</span>, handler Handler)</span></span> { DefaultServeMux.Handle(pattern, handler) }\\n\\n<span class=\\\"hljs-function\\\"><span class=\\\"hljs-keyword\\\">func</span> <span class=\\\"hljs-title\\\">HandleFunc</span><span class=\\\"hljs-params\\\">(pattern <span class=\\\"hljs-keyword\\\">string</span>, handler <span class=\\\"hljs-keyword\\\">func</span>(ResponseWriter, *Request)</span>)</span> {\\n\\tDefaultServeMux.HandleFunc(pattern, handler)\\n}\\n\\n<span class=\\\"hljs-function\\\"><span class=\\\"hljs-keyword\\\">func</span> <span class=\\\"hljs-params\\\">(mux *ServeMux)</span> <span class=\\\"hljs-title\\\">HandleFunc</span><span class=\\\"hljs-params\\\">(pattern <span class=\\\"hljs-keyword\\\">string</span>, handler <span class=\\\"hljs-keyword\\\">func</span>(ResponseWriter, *Request)</span>)</span> {\\n\\t<span class=\\\"hljs-keyword\\\">if</span> handler == <span class=\\\"hljs-literal\\\">nil</span> {\\n\\t\\t<span class=\\\"hljs-built_in\\\">panic</span>(<span class=\\\"hljs-string\\\">&quot;http: nil handler&quot;</span>)\\n\\t}\\n\\tmux.Handle(pattern, HandlerFunc(handler))\\n}</code></pre><h2>サードパーティー製のマルチプレクサ</h2>\\n<p>標準でも特に辛くない。 <em><strong>request.Method</strong></em> でメソッドも取得できるのでかなり使い勝手もいい。</p>\\n<pre><code class=\\\"hljs\\\">mux.HandleFunc(<span class=\\\"hljs-string\\\">&quot;/users/create&quot;</span>, createUsers)\\nmux.HandleFunc(<span class=\\\"hljs-string\\\">&quot;/users/read/&quot;</span>, readUsers)\\nmux.HandleFunc(<span class=\\\"hljs-string\\\">&quot;/users/update/&quot;</span>, updateUsers)\\nmux.HandleFunc(<span class=\\\"hljs-string\\\">&quot;/users/delete/&quot;</span>, deleteUsers)\\n\\n<span class=\\\"hljs-function\\\"><span class=\\\"hljs-keyword\\\">func</span> <span class=\\\"hljs-title\\\">readerUsers</span><span class=\\\"hljs-params\\\">(writer http.ResponseWriter, request *http.Request)</span></span> {\\n\\tsub := strings.TrimPrefix(request.URL.Path, <span class=\\\"hljs-string\\\">&quot;/users/read/&quot;</span>)\\n\\tuserId, err := strconv.Atoi(sub) <span class=\\\"hljs-comment\\\">// これで /users/read/:id の id を取得できる</span>\\n}</code></pre><p>下記のような、 <em><strong>/users/:user_id/tasks/:task_id</strong></em> みたいに解析を結構頑張らないといけない場合は結構辛い。</p>\\n<pre><code class=\\\"hljs\\\">mux.HandleFunc(<span class=\\\"hljs-string\\\">&quot;/users/2/tasks/create&quot;</span>, createUsers)\\nmux.HandleFunc(<span class=\\\"hljs-string\\\">&quot;/users/2/tasks/read/&quot;</span>, readUsers)\\nmux.HandleFunc(<span class=\\\"hljs-string\\\">&quot;/users/2/tasks/update/&quot;</span>, updateUsers)\\nmux.HandleFunc(<span class=\\\"hljs-string\\\">&quot;/users/2/tasks/delete/&quot;</span>, deleteUsers)</code></pre><p>この辺が良さそう。</p>\\n<ul>\\n<li>https://github.com/gorilla/mux</li>\\n<li>https://github.com/julienschmidt/httprouter</li>\\n</ul>\\n\",\n  \"dir\": \"articles\",\n  \"base\": \"20210723021243.json\",\n  \"ext\": \".json\",\n  \"sourceBase\": \"20210723021243.md\",\n  \"sourceExt\": \".md\"\n}"}},"__N_SSG":true}