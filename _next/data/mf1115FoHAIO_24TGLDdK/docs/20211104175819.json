{"pageProps":{"docBody":{"id":"20211104175819","title":"並行処理の考え方","content":"\n## 競合状態\nデータ処理に順番あり可能性がある。処理の間に 1 時間掛かっても問題ないか?と考える。\n\n## アトミック性\n処理が行われたか、行われたかったかの 2 パターンしかない。処理を分解したときにこれ以上分解できない単位。\n`i++` は非アトミック。\n- i の値を取得する\n- i の値を 1 増やす\n- i の値を保存する\n\nアトミックな処理であれば複数のゴルーチンで安全に扱える。\n\n## メモリアクセス同期\n排他処理が必要。 `sync.Mutex` で解決できる。\n\n## デッドロック\n- 相互排他\n  - ある並行プロセスがリソースに対して排他的な権利をどの時点でも保持している\n- 条件待ち\n  - ある並行プロセスがリソースの保持と追加のリソース街を同時に行う\n- 横取り不可\n  - ある並行プロセスによって保持されているリソースはそのプロセスによってのみ開放される\n- 循環待ち\n  - ある並行プロセス ( P1 ) は他の並行プロセス ( P2 ) を待たなければならない.そして P2 は P1 を待っている\n\n## ライブロック\nライブロックが起こる原因の多くは、試行回数に上限がない。 2 つの並行プロセスが互いのデッドロックを予防して起こる。\n\n## リソース枯渇\nライブロックのように 1 つ以上の貪欲なプロセスが他のリソースを奪うことで起こる。\n\n```go\npackage main\n\nimport (\n\t\"fmt\"\n\t\"sync\"\n\t\"time\"\n)\n\nfunc main() {\n\tvar wg sync.WaitGroup\n\tvar sharedLock sync.Mutex\n\tconst RUNTIME = 1 * time.Second\n\n\tgreedWorker := func() {\n\t\tdefer wg.Done()\n\n\t\tvar count int\n\t\tfor begin := time.Now(); time.Since(begin) <= RUNTIME; {\n\t\t\tsharedLock.Lock()\n\t\t\ttime.Sleep(3 * time.Nanosecond)\n\t\t\tsharedLock.Unlock()\n\t\t\tcount++\n\t\t}\n\t\tfmt.Printf(\"greed worker loops: %v\\n\", count)\n\t}\n\n\tpoliteWorker := func() {\n\t\tdefer wg.Done()\n\n\t\tvar count int\n\t\tfor begin := time.Now(); time.Since(begin) <= RUNTIME; {\n\t\t\tsharedLock.Lock()\n\t\t\ttime.Sleep(1 * time.Nanosecond)\n\t\t\tsharedLock.Unlock()\n\t\t\tsharedLock.Lock()\n\t\t\ttime.Sleep(1 * time.Nanosecond)\n\t\t\tsharedLock.Unlock()\n\t\t\tsharedLock.Lock()\n\t\t\ttime.Sleep(1 * time.Nanosecond)\n\t\t\tsharedLock.Unlock()\n\t\t\tcount++\n\t\t}\n\t\tfmt.Printf(\"polite worker loops: %v\\n\", count)\n\t}\n\n\twg.Add(2)\n\tgo greedWorker()\n\tgo politeWorker()\n\twg.Wait()\n}\n```\n\n```bash\n$ go run main.go \ngreed worker loops: 867215\npolite worker loops: 524996\n```\n"}},"__N_SSG":true}