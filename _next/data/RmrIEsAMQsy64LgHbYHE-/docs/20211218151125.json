{"pageProps":{"contents":{"id":"20211218151125","title":"TypeScript 勉強する","body":"\n## 型いろいろ\n\n### discriminated unions\n意味のある共通のプロパティをもたせて判別に使う。\n```ts\ninterface Bird {\n  flySpped: number;\n  type: \"bird\";\n}\n\ninterface Horse {\n  runSpeed: number;\n  type: \"horse\";\n}\n\ntype Animal = Bird | Horse;\n\nfunction animalSpeed(animal: Animal) {\n  switch (animal.type) {\n    case \"bird\":\n      console.log(animal.flySpped);\n      break;\n    case \"horse\":\n      console.log(animal.runSpeed);\n  }\n}\n```\n\n### 型キャスト\n文字列を数値に変換する場合、 `+` を変数の前につけるだけでよい。\n```ts\nconst a = \"1\";\nconst b = \"2\";\n\nconst result = +a + +b;\nconsole.log(result); // 3\n```\n\n前に `<>` で型を書くか、後ろに `as` を付けて型キャストできる。\n祖運剤が確定している場合は `!` を付けてエラーを回避できる。\n```ts\nconst input1 = <HTMLInputElement> document.getElementById(\"num\")!;\nconst input2 = document.getElementById(\"num\")! as HTMLInputElement;\n```\n\n### インデックス型\n```ts\ninterface ErrorInterface {\n  [prop: string]: string;\n}\n\nconst errorMessage: ErrorInterface = {\n  email: \"hoge\",\n  name: \"foo\",\n  message: \"fuga\",\n};\n\nconsole.log(errorMessage); // { email: \"hoge\", name: \"foo\", message: \"fuga\" }\n```\n\n### 関数オーバーロード\n受け取る型と返す型のパターンを関数の直前に記述する。\n```ts\ntype Input = string | number;\n\nfunction add(a: number, b: number): number;\nfunction add(a: string, b: number): string;\nfunction add(a: number, b: string): string;\nfunction add(a: string, b: string): string;\nfunction add(a: Input, b: Input) {\n  if (typeof a === \"string\" || typeof b === \"string\") {\n    return a.toString() + b.toString();\n  }\n  return a + b;\n}\n\nconsole.log(add(1, 2));\nconsole.log(add(\"1\", 2));\n```\n\n### オプショナルチェイン\n`?` を使ってオブジェクトに安全にアクセスする。\n```ts\nconst fetched = {\n  id: \"id1\",\n  name: \"hoge\",\n  job: {\n    title: \"Dev\",\n    desc: \"developer\",\n  },\n};\n\nconsole.log(fetched && fetched.job && fetched.job.title);\nconsole.log(fetched?.job?.title);\n```\n\n### null 合体演算子\n`null` か `undefined` のときのみ判定できる。\n```ts\nlet input = \"\";\nconst inputData = input ?? \"Default\";\nconsole.log(inputData);\n```\n\n## class\n```ts\nclass Person {\n  id: string;\n  name: string;\n\n  constructor(id: string, n: string) {\n    this.id = id;\n    this.name = n;\n  }\n  printData() {\n    console.log(`ID: ${this.id}; Name: ${this.name}`);\n  }\n}\n\nconst person = new Person(\"user1\", \"hoge\");\nperson.printData(); // ID: user1; Name: hoge\n```\n\nフィールドとコンストラクタはまとめる事ができる。やり方は `constractor` にアクセス修飾子を書くだけ。\n引数の名前はフィールド名にしないといけない。\n```ts\nclass Person {\n  constructor(public id: string, public name: string) {\n  }\n  printData() {\n    console.log(`ID: ${this.id}; Name: ${this.name}`);\n  }\n}\n\nconst person = new Person(\"user1\", \"hoge\");\nperson.printData(); // ID: user1; Name: hoge\n```\n\n`private` は外部からアクセスできない。 `readonly` は初期化後に変更ができない。\nまた `protected` はサブクラスからのみアクセス可能。\n```ts\nclass Person {\n  constructor(private readonly id: string, public name: string) {\n  }\n  printData() {\n    console.log(`ID: ${this.id}; Name: ${this.name}`);\n  }\n}\n\nconst person = new Person(\"user1\", \"hoge\");\nperson.printData(); // ID: user1; Name: hoge\n```\n\n### getter & setter\n`()` は不要。プロパティのように実行する。\n```ts\nclass Person {\n  private _report: string;\n\n  constructor(private readonly id: string, public name: string) {\n    this._report = \"\";\n  }\n\n  get report() {\n    return this._report;\n  }\n\n  set report(input: string) {\n    this._report = input;\n  }\n\n  printData() {\n    console.log(`ID: ${this.id}; Name: ${this.name}`);\n  }\n}\n\nconst person = new Person(\"user1\", \"hoge\");\nperson.printData(); // ID: user1; Name: hoge\n\nperson.report = \"report1\";\nconsole.log(person.report); // report1\n```\n\n### static メソッド & static プロパティ\nstatic メソッドや static プロパティには this でアクセスできない ( インスタンスからアクセスできない )。\n```ts\nclass Person {\n  static year = 2021;\n}\n\nconsole.log(Person.year); // 2021\n```\n\n### 抽象メソッド\n抽象メソッドは抽象クラス内でのみ使える。抽象メソッドは関数の構造のみを定義しておく。\n抽象クラスからはインスタンスを作れない。継承したサブクラスからはインスタンスを作れる。\n```ts\nabstract class Product {\n  constructor(protected readonly id: string, public name: string) {\n  }\n  abstract describe(): void;\n}\n\nclass Product1 extends Product {\n  constructor(id: string, name: string) {\n    super(id, name);\n  }\n\n  describe(): void {\n    console.log(`ID: ${this.id}; Name: ${this.name}`);\n  }\n}\n\nconst product1 = new Product1(\"1\", \"hoge\");\nproduct1.describe(); // ID: 1; Name: hoge\n```\n\n### シングルトンパターン\nオブジェクトを 1 つしか作らせたくない場合に使う。\n```ts\nclass Person {\n  private static instance: Person;\n\n  static getInstance() {\n    if (Person.instance) {\n      return this.instance;\n    }\n    this.instance = new Person();\n    return this.instance;\n  }\n}\n\nconst person = new Person();\n```\n\n### interface\nオブジェクトがどんな形であるか定義する。\ninterface とカスタムタイプの使い分けは、オブジェクトの構造を記述するときは interface を使う。\nカスタムタイプは union 型など様々な型を定義できる。 interface を使えばオブジェクトの構造を定義したいという意図を明確にできる。\nまた interface は readonly 継承もできる。\n```ts\ninterface Named {\n  readonly name: string\n}\n\ninterface Greetable extends Named {\n  hello(phrase: string): void\n}\n```\n\n### implements\n`implements` を使って実装する。\n抽象クラスとの違いは、 interface では値や実装を持たない。抽象クラスは値や実装を混在させる事ができる。\n```ts\ninterface PersonInterface {\n  id: string;\n  name: string;\n  describe(): void;\n}\n\nclass Person implements PersonInterface {\n  id: string;\n  name: string;\n\n  constructor(id: string, n: string) {\n    this.id = id;\n    this.name = n;\n  }\n\n  describe(): void {\n    console.log(`ID: ${this.id}; Name: ${this.name}`);\n  }\n}\n\nconst person = new Person(\"1\", \"hoge\");\nperson.describe(); // ID: 1; Name: hoge\n```\n\n## ジェネリクス\n関数の後ろに `<>` を付けて表現する。\n```ts\nfunction mergeObject(objA: object, objB: object) {\n  return Object.assign(objA, objB);\n}\n\nconsole.log(mergeObject({ id: \"1\" }, { name: \"hoge\" })); // { id: \"1\", name: \"hoge\" }\n```\n\n```ts\nfunction mergeObject<T>(objA: T, objB: T) {\n  return Object.assign(objA, objB);\n}\n\nconsole.log(mergeObject({ id: \"1\" }, { name: \"hoge\" })); // { id: \"1\", name: \"hoge\" }\n```\n\n### 制約をつける\nextends を使う。\n```ts\nfunction mergeObject<T extends object, U extends object>(objA: T, objB: U) {\n  return Object.assign(objA, objB);\n}\n\nconsole.log(mergeObject({ id: \"1\" }, { name: \"hoge\" })); // { id: \"1\", name: \"hoge\" }\n```\n\n### keyof\n`keyof` を使うことでオブジェクトのキーの制約を持たせる。\n```ts\nfunction addConvert<T extends object, U extends keyof T>(obj: T, key: U) {\n  return \"value: \" + obj[key];\n}\n\nconsole.log(addConvert({ id: \"1\", name: \"hoge\" }, \"name\")); // value: hoge\n```\n\n### ジェネリクスクラス\nクラスの後ろに `<>` を付けて表現する。\n```ts\nclass DataStore<T extends string | number> {\n  private data: T[] = [];\n\n  addItem(item: T) {\n    this.data.push(item);\n  }\n  removeItem(item: T) {\n    if (this.data.indexOf(item) === -1) {\n      return;\n    }\n    this.data.splice(this.data.indexOf(item), 1);\n  }\n  getItems() {\n    return [...this.data];\n  }\n}\n\nconst stringDate = new DataStore<string>();\nconst numberData = new DataStore<number>();\nstringDate.addItem(\"data1\");\nstringDate.addItem(\"data2\");\nnumberData.addItem(1);\nnumberData.addItem(2);\nstringDate.removeItem(\"data2\");\nnumberData.removeItem(2);\nconsole.log(stringDate.getItems()); // [ \"data1\" ]\nconsole.log(numberData.getItems()); // [ 1 ]\n```\n\n### Partial\n一時的に別の型に切り替えることができる。\n`Partial` で最終的にキャストされる型を指定する。\nreturn するときはキャストが必要。\n```ts\ninterface Todo {\n  title: string;\n  desc: string;\n  date: Date;\n}\n\nfunction createTodo(\n  title: string,\n  desc: string,\n  date: Date,\n): Todo {\n  let todo: Partial<Todo> = {};\n  todo.title = title;\n  todo.desc = desc;\n  todo.date = date;\n  return todo as Todo;\n}\n```\n"}},"__N_SSG":true}