{"pageProps":{"docBody":{"id":"20211103154457","title":"Go の context","content":"\n## context パッケージ\ncontext パッケージを見てみる.\n```go\ntype Context interface {\n\tDeadline() (deadline time.Time, ok bool)\n\tDone() <-chan struct{}\n\tErr() error\n\tValue(key interface{}) interface{}\n}\n```\n\ncontext パッケージのざっくりとした目的は以下の通り.\n- 適切なキャンセルを行う機能を提供する\n- リクエストのデータの置き場を提供する\n\nキャンセルには 3 つ側面がある.\n- ゴルーチンの親がキャンセルしたい場合\n- ゴルーチンの子をキャンセルしたい場合\n- ゴルーチン内のブロックしている処理がキャンセルされるように中断できる必要がある場合\n\n## 使い方\nContext の空インスタンスを作る関数は以下の 2 つ.\n- `func Background() Context`\n  - 通常使うのはこっち.空の Context を返す\n- `func TODO() Context`\n  - 本番環境で使われることを想定していない.どの Context を使っていいかわからないとき,もしくは上流の実装が終わっていないときに使う\n\n### Done / Deadline メソッド\nキャンセルに使う.\n\n- `context.WithCancel`\n```go\nfunc context.WithCancel(parent context.Context) (ctx context.Context, cancel context.CancelFunc)\n```\n\nキャンセルする側は `context.WithCancel()` によって生成された cancal 関数を実行することで, キャンセルされる側の context の Done メソッドが close される.\n```go\nctx, cancel := context.WithCancel(context.Background())\n// 処理\ncancel()\n```\n\nキャンセルされる側は `ctx.Done()` からキャンセルを受け取る.\n```go\n<-ctx.Done()\n```\n\n- `context.WithDeadline`\n```go\nfunc context.WithDeadline(parent context.Context, d time.Time) (context.Context, context.CancelFunc)\n```\nキャンセルする側は `context.WithDeadline` の生成時に停止したい時刻を設定することでその時刻を超えたタイミングでキャンセルが実行される.\n```go\nctx, cancel := context.WithDeadline(context.Background(), time.Now().Add(time.Second))\n```\n\n- `context.Timeout`\n```go\nfunc context.WithTimeout(parent context.Context, timeout time.Duration) (context.Context, context.CancelFunc)\n```\nキャンセルする側は `context.Timeout` の生成時に停止したい時間は設定することでその時間を超えたタイミングでキャンセルが実行される.\n```go\nctx, cancel := context.WithTimeout(context.Background(), time.Second)\n```\n\n`context.WithDeadline` , `context.Timeout` を使ったキャンセルされる側は `context.WithCancel` と同様に `ctx.Done()` からキャンセルを受け取る.\ncontext 生成時に得られる canacl は close されたチャネルに対しては何も実行されないので,タイムアウトの処理をしていても明示的に cancel は呼ぶほうが良い.\n\ncontext に対してタイムアウトが設定されているかどうかを確認するには, context の `Deadline` メソッドを実行する.\n```go\ntype Context interface {\n\tDeadline() (deadline time.Time, ok bool)\n}\n```\n設定されている場合,第 2 返り値は true で 第 1 返り値にはその時刻が設定されている.\n\n### Err メソッド\n```go\ntype Context interface {\n\tErr() error\n}\n```\n- context がキャンセルされていない場合は `nil`\n- context が明示的にキャンセルされている場合は `Canceled`\n- context がタイムアウトしていた場合は `DeadlineExceeded`\n\n```go\nLOOP:\n\tfor {\n\t\tselect {\n\t\tcase <-ctx.Done():\n\t\t\tif err := ctx.Err(); errors.Is(err, context.Canceled) {\n\t\t\t\tfmt.Println(\"Canceled\")\n\t\t\t} else if errors.Is(err, context.DeadlineExceeded) {\n\t\t\t\tfmt.Println(\"DeadlineExceeded\")\n\t\t\t}\n\t\t\tbreak LOOP\n\t\t}\n\t}\n```\n\n### Value メソッド\n```go\nfunc context.WithValue(parent context.Context, key interface{}, val interface{}) context.Context\n```\n`WithValue` を使うと context に key-value 形式でデータを保持できる.\n\n```go\nctx, cancel := context.WithCancel(context.Background())\nctx = context.WithValue(ctx, \"id\", 1)\nctx = context.WithValue(ctx, \"user\", \"abc\")\n```\n\n取り出すときはアサーションして値を取り出す.\n```go\nid, user := ctx.Value(\"id\").(int), ctx.Value(\"user\").(string)\n```\n"}},"__N_SSG":true}