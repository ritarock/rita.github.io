{"pageProps":{"docBody":{"id":"20220105212211","title":"TypeScript の Utility Types","content":"\n## Partial<Type>\n`Partial<Type>` で指定した型に一時的に切り替えることができる。値を返すときはキャストする必要がある。\n```ts\ninterface Todo {\n  title: string;\n  desc: string;\n  date: Date;\n}\n\nfunction createTodo(\n  title: string,\n  desc: string,\n  date: Date,\n): Todo {\n  // let todo: Todo = {} // ここでのエラーを防ぐ\n  let todo: Partial<Todo> = {};\n  todo.title = title;\n  todo.desc = desc;\n  todo.date = date;\n  return todo as Todo;\n}\n```\n\n## Required<Type>\nパラメータが欠損したらエラー。\n```ts\ninterface Todo {\n  title: string;\n  desc: string;\n  date: Date;\n}\n\nfunction createTodo(\n  title: string,\n  desc: string,\n  date: Date,\n): Todo {\n  const todo: Required<Todo> = {\n    title: title,\n    desc: desc,\n    date: date,\n  };\n\n  return todo;\n}\n```\n\n## Readonly<Type>\n初期化したあとにパラメータを変更できないようにする。\n```ts\ninterface Todo {\n  title: string;\n}\n\nconst todo: Readonly<Todo> = {\n  title: \"create\",\n};\n\n// todo.title = \"update\"\n```\n\n## Record<Keys, Type>\nKey とその型を指定できる。辞書として使いたい場合に適している。\n```ts\ninterface CatInfo {\n  age: number;\n  breed: string;\n}\n\ntype CatName = \"miffy\" | \"boris\" | \"mordred\";\n\nconst cats: Record<CatName, CatInfo> = {\n  miffy: { age: 10, breed: \"Persian\" },\n  boris: { age: 5, breed: \"Maine Coon\" },\n  mordred: { age: 16, breed: \"British Shorthair\" },\n};\n\nconsole.log(cats);\n// {\n//   miffy: { age: 10, breed: \"Persian\" },\n//   boris: { age: 5, breed: \"Maine Coon\" },\n//   mordred: { age: 16, breed: \"British Shorthair\" }\n// }\n\nconsole.log(cats.boris);\n// { age: 5, breed: \"Maine Coon\" }\n```\n\n## Pick<Type, Keys>\nkeys に指定したプロパティの型になる。\n```ts\ninterface Todo {\n  title: string;\n  desc: string;\n  completed: boolean;\n}\n\ntype TodoPreview = Pick<Todo, \"title\" | \"completed\">;\n\nconst todo: TodoPreview = {\n  title: \"Clean room\",\n  completed: false,\n};\n```\n\n## Omit<Type, Keys>\nkeys に指定した以外のプロパティの型になる。\n```ts\ninterface Todo {\n  title: string;\n  desc: string;\n  completed: boolean;\n  createdAt: number;\n}\n\ntype TodoPreview = Omit<Todo, \"desc\">;\n\nconst todo: TodoPreview = {\n  title: \"Clean room\",\n  completed: false,\n  createdAt: 1000,\n};\n```\n\n## Exclude<Type, ExcludedUnion>\n`Exclude<T, U>` T から U を除いた型になる。\n```ts\ntype T0 = Exclude<\"a\" | \"b\" | \"c\", \"a\">;\n// type T0 = \"b\" | \"c\"\n\ntype T1 = Exclude<\"a\" | \"b\" | \"c\", \"a\" | \"b\">;\n// type T1 = \"c\"\n\ntype T2 = Exclude<string | number | (() => void), Function>;\n// type T2 = string | number\n```\n\n## Extract<Type, Union>\n`Extract<T, U>` T と U のユニオン型になる。\n```ts\ntype T0 = Extract<\"a\" | \"b\" | \"c\", \"a\" | \"f\">;\n// type T0 = \"a\"\n\ntype T1 = Extract<string | number | (() => void), Function>;\n// type T1 = () => void\n```\n\n## NonNullable<Type>\n`null` と `undefined` を除いた型になる。\n```ts\ntype T0 = NonNullable<string | number | undefined>;\n// type T0 = string | number\n\ntype T1 = NonNullable<string[] | null | undefined>;\n// type T1 = string[]\n```\n\n## Parameters<Type>\n`Parameters<T>` では T は関数型の必要がある。 T が関数のとき T の引数一覧をタプル型で作成する。\n```ts\ndeclare function f1(arg: { a: number; b: string }): void;\n\ntype T0 = Parameters<() => string>;\n// type T0 = []\n\ntype T1 = Parameters<(s: string) => void>;\n// type T1 = [s: string]\n\ntype T2 = Parameters<<T>(arg: T) => T>;\n// type T2 = [arg: unknown]\n\ntype T3 = Parameters<typeof f1>;\n// type T3 = [arg: {\n//   a: number;\n//   b: string;\n// }]\n\ntype F = (arg1: string, arg2: number) => string;\ntype F1 = Parameters<F>;\n// type F1 = [arg1: string, arg2: number]\n\nconst v: F1 = [\"a\", 123];\n```\n\n## ConstructorParameters<Type>\nclass のコンストラクタ関数の引数の型からタプル型を作成する。\n```ts\ntype T0 = ConstructorParameters<ErrorConstructor>;\n// type T0 = [message?: string]\n\ntype T1 = ConstructorParameters<FunctionConstructor>;\n// type T1 = string[]\n\nclass Person {\n  constructor(public id: number, public name: string) {}\n}\n\ntype P = ConstructorParameters<typeof Person>;\n// type P = [id: number, name: string]\n```\n\n## ReturnType<Type>\n戻り値からなる型になる。\n```ts\ndeclare function f1(): { a: number; b: string };\n\ntype T0 = ReturnType<() => string>;\n// type T0 = string\n\ntype T1 = ReturnType<(s: string) => void>;\n// type T1 = void\n\ntype T2 = ReturnType<<T>() => T>;\n// type T2 = unknown\n\ntype T3 = ReturnType<<T extends U, U extends number[]>() => T>;\n// type T3 = number[]\n\ntype T4 = ReturnType<typeof f1>;\n// type T4 = {\n//   a: number;\n//   b: string;\n// }\n```\n\n## InstanceType<Type>\nコンストラクタの戻り値からなる型。\n```ts\nclass C {\n  x = 0;\n  y = 0;\n}\n\nclass Foo {}\n\ntype T0 = InstanceType<typeof C>;\n// type T0 = C\n\ntype T1 = InstanceType<typeof Foo>;\n// type T1 = Foo\n```\n\n## ThisParameterType<Type>\n関数型の this パラメータの型を抽出した型になる。\n```ts\nfunction toHex(this: number) {\n  return this.toString();\n}\n\nfunction numberToString(n: ThisParameterType<typeof toHex>) {\n  return toHex.apply(n);\n}\n\nconsole.log(numberToString(123));\n// 123\n```\n\n## OmitThisParameter<Type>\n関数型の this パラメータの型を除いた型になる。\n```ts\nfunction toHex(this: number) {\n  return this.toString();\n}\n\nconst fiveToHex: OmitThisParameter<typeof toHex> = toHex.bind(123);\n\nconsole.log(fiveToHex());\n// 123\n```\n\n## ThisType<Type>\nオブジェクト内の this の型を正しい型にする。\n```ts\ninterface User {\n  name: string;\n}\n\ninterface Greeting {\n  hello(): void;\n}\n\nconst user: Greeting & ThisType<User> = {\n  hello() {\n    console.log(`Hello ${this.name}`);\n  },\n};\n```\n"}},"__N_SSG":true}