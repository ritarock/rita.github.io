{"pageProps":{"docBody":{"id":"20210723021243","title":"Golang の http/net について調べた","content":"\n## サーバ\n何もしないサーバを起動。\n```go\npackage main\n\nimport \"net/http\"\n\nfunc main() {\n\thttp.ListenAndServe(\"\", nil)\n}\n```\n\n`ListenAndServe` はネットワークアドレスとハンドラを引数で受け取る。ハンドラが nil の場合は `DefaultServerMux` が使われる。\n\nServer の構造体はこんな感じ。\n```go\ntype Server struct {\n\tAddr string\n\tHandler Handler\n\tTLSConfig *tls.Config\n\tReadTimeout time.Duration\n\tReadHeaderTimeout time.Duration\n\tWriteTimeout time.Duration\n\tIdleTimeout time.Duration\n\tMaxHeaderBytes int\n\tTLSNextProto map[string]func(*Server, *tls.Conn, Handler)\n\tConnState func(net.Conn, ConnState)\n\tErrorLog *log.Logger\n\tBaseContext func(net.Listener) context.Context\n\tConnContext func(ctx context.Context, c net.Conn) context.Context\n\tinShutdown atomicBool\n\tdisableKeepAlives int32\n\tnextProtoOnce     sync.Once\n\tnextProtoErr      error\n\tmu         sync.Mutex\n\tlisteners  map[*net.Listener]struct{}\n\tactiveConn map[*conn]struct{}\n\tdoneChan   chan struct{}\n\tonShutdown []func()\n}\n```\n\n設定を変更する場合は Server の構造体に値を指定する。\n```go\nfunc main() {\n\tserver := http.Server{\n\t\tAddr:    \"0.0.0.0:8080\",\n\t\tHandler: nil,\n\t}\n\tserver.ListenAndServe()\n```\n\n### ハンドラとハンドラ関数\nハンドラがない場合すべてのリクエストで 404 を返す。\n\nハンドラとは、 `ServerHTTP メソッド` を持ったインターフェースのことを指す。\nこのメソッドは、 `インターフェース HTTPResponseWriter` と `構造体 Request のポインタ` の 2 つの引数を取る。\nつまり、 `ServerHTTP(http.ResponseWriter, *http.Request)` をもつインターフェースがハンドラになる。\n```go\ntype HelloHandler struct{}\n\nfunc (h *HelloHandler) ServeHTTP(writer http.ResponseWriter, request *http.Request) {\n\tfmt.Fprintf(writer, \"hello\")\n}\n\nfunc main() {\n\thelloHandler := new(HelloHandler)\n\tserver := http.Server{\n\t\tAddr:    \"0.0.0.0:8080\",\n\t\tHandler: helloHandler,\n\t}\n\tserver.ListenAndServe()\n}\n```\n\nこの状態だと、すべてのアクセスが 1 つのハンドラに行く。\n\n実際は URL ごとに異なるハンドラで処理する必要があるため Handler フィールドに値を指定しない ( デフォルトで DefaultServerMux を使う ) 。\n\n```go\ntype HelloHandler struct{}\ntype WorldHandler struct{}\n\nfunc (h *HelloHandler) ServeHTTP(writer http.ResponseWriter, request *http.Request) {\n\tfmt.Fprintf(writer, \"hello\")\n}\nfunc (w *WorldHandler) ServeHTTP(writer http.ResponseWriter, request *http.Request) {\n\tfmt.Fprintf(writer, \"world\")\n}\n\nfunc main() {\n\thelloHandler := new(HelloHandler)\n\tworldHandler := new(WorldHandler)\n\tserver := http.Server{\n\t\tAddr: \"0.0.0.0:8080\",\n\t}\n\thttp.Handle(\"/hello\", helloHandler)\n\thttp.Handle(\"/world\", worldHandler)\n\tserver.ListenAndServe()\n}\n```\n\n`http.Handle` は実際には DefaultServeMux の Handle メソッドを呼び出している。\n\n```go\nfunc Handle(pattern string, handler Handler) { DefaultServeMux.Handle(pattern, handler) }\n```\n\nハンドラとは、 `ServerHTTP(http.ResponseWriter, *http.Request)` をもつインターフェースのこと。\nハンドラ関数とは、ハンドラのように振る舞う関数。リクエストのポインタを受け取ることができる。\n\n```go\npackage main\n\nimport (\n\t\"fmt\"\n\t\"net/http\"\n)\n\ntype HelloHandler struct{}\ntype WorldHandler struct{}\n\nfunc (h *HelloHandler) ServeHTTP(writer http.ResponseWriter, request *http.Request) {\n\tfmt.Fprintf(writer, \"hello\")\n}\nfunc (w *WorldHandler) ServeHTTP(writer http.ResponseWriter, request *http.Request) {\n\tfmt.Fprintf(writer, \"world\")\n}\n\nfunc hello(writer http.ResponseWriter, request *http.Request) {\n\tfmt.Fprintf(writer, \"hello\")\n}\nfunc world(writer http.ResponseWriter, request *http.Request) {\n\tfmt.Fprintf(writer, \"world\")\n}\n\nfunc main() {\n\thelloHandler := new(HelloHandler)\n\tworldHandler := new(WorldHandler)\n\tserver := http.Server{\n\t\tAddr: \"0.0.0.0:8080\",\n\t}\n\thttp.Handle(\"/hello\", helloHandler)\n\thttp.Handle(\"/world\", worldHandler)\n\thttp.HandleFunc(\"/hello2\", hello)\n\thttp.HandleFunc(\"/world2\", world)\n\tserver.ListenAndServe()\n}\n```\n\n### 何が違うのか\nやってることは `DefaultServeMux.Handle(pattern, handler)` なので同じ。\n既存のインターフェースがある場合は、 `ServeHTTP` メソッドを追加するだけでハンドラになるからそういった場合は、 `http.Handle` のほうが手軽。\n\n```go\nfunc Handle(pattern string, handler Handler) { DefaultServeMux.Handle(pattern, handler) }\n\nfunc HandleFunc(pattern string, handler func(ResponseWriter, *Request)) {\n\tDefaultServeMux.HandleFunc(pattern, handler)\n}\n\nfunc (mux *ServeMux) HandleFunc(pattern string, handler func(ResponseWriter, *Request)) {\n\tif handler == nil {\n\t\tpanic(\"http: nil handler\")\n\t}\n\tmux.Handle(pattern, HandlerFunc(handler))\n}\n```\n\n## サードパーティー製のマルチプレクサ\n標準でも特に辛くない。 `request.Method` でメソッドも取得できるのでかなり使い勝手もいい。\n```go\nmux.HandleFunc(\"/users/create\", createUsers)\nmux.HandleFunc(\"/users/read/\", readUsers)\nmux.HandleFunc(\"/users/update/\", updateUsers)\nmux.HandleFunc(\"/users/delete/\", deleteUsers)\n\nfunc readerUsers(writer http.ResponseWriter, request *http.Request) {\n\tsub := strings.TrimPrefix(request.URL.Path, \"/users/read/\")\n\tuserId, err := strconv.Atoi(sub) // これで /users/read/:id の id を取得できる\n}\n```\n\n下記のような、 `/users/:user_id/tasks/:task_id` みたいに解析を結構頑張らないといけない場合は結構辛い。\n```go\nmux.HandleFunc(\"/users/2/tasks/create\", createUsers)\nmux.HandleFunc(\"/users/2/tasks/read/\", readUsers)\nmux.HandleFunc(\"/users/2/tasks/update/\", updateUsers)\nmux.HandleFunc(\"/users/2/tasks/delete/\", deleteUsers)\n```\n\nこの辺が良さそう。\n- https://github.com/gorilla/mux\n- https://github.com/julienschmidt/httprouter\n"}},"__N_SSG":true}