{"pageProps":{"docBody":{"id":"20210429182820","title":"Golang の 並列 / 並行 処理でいろいろ","body":"\n## 並列 / 並行 処理\n- 並列処理\n  - Parallelism\n    - 同時に同じ処理が複数走る\n- 並行処理\n  - Concurrency\n    - 同時に色々な処理が走る\n\n## channel を使う\n```go\npackage main\n\nimport (\n\t\"fmt\"\n\t\"time\"\n)\n\nfunc process(num int, str string) {\n\tfor i := 0; i < num; i++ {\n\t\ttime.Sleep(1 * time.Second)\n\t\tfmt.Println(i, str)\n\t}\n}\n\nfunc main() {\n\tfmt.Println(\"Start\")\n\tprocess(2, \"A\")\n\tprocess(2, \"B\")\n\tprocess(2, \"C\")\n\tfmt.Println(\"Finish\")\n}\n\n// Start\n// 0 A\n// 1 A\n// 0 B\n// 1 B\n// 0 C\n// 1 C\n// Finish\n// \n// ________________________________________________________\n// Executed in    6.30 secs      fish           external\n//    usr time  192.00 millis  172.00 micros  191.83 millis\n//    sys time  201.91 millis  759.00 micros  201.15 millis\n```\n\nprocess の処理を並列化する。\n```go\npackage main\n\nimport (\n\t\"fmt\"\n\t\"time\"\n)\n\nfunc process(num int, str string) {\n\tfor i := 0; i < num; i++ {\n\t\ttime.Sleep(1 * time.Second)\n\t\tfmt.Println(i, str)\n\t}\n}\n\n\nfunc main() {\n\tchA := make(chan bool)\n\tchB := make(chan bool)\n\tchC := make(chan bool)\n\tfmt.Println(\"Start\")\n\n\tgo func() {\n\t\tprocess(2, \"A\")\n\t\tchA <- true\n\t}()\n\n\tgo func() {\n\t\tprocess(2, \"B\")\n\t\tchB <- true\n\t}()\n\n\tgo func() {\n\t\tprocess(2, \"C\")\n\t\tchC <- true\n\t}()\n\n\t<-chA\n\t<-chB\n\t<-chC\n\n\tfmt.Println(\"Finish\")\n}\n\n// Start\n// 0 B\n// 0 A\n// 0 C\n// 1 C\n// 1 A\n// 1 B\n// Finish\n// \n// ________________________________________________________\n// Executed in    2.29 secs      fish           external\n//    usr time  194.02 millis  178.00 micros  193.84 millis\n//    sys time  207.43 millis  862.00 micros  206.57 millis\n```\n\n## sync.WaitGroup を使う\n```go\npackage main\n\nimport \"fmt\"\n\ntype Item struct {\n\tId   int\n\tName string\n}\n\nfunc execLoop(list []Item) {\n\tfor _, item := range list {\n\t\tdoSomething(item)\n\t}\n}\n\nfunc doSomething(item Item) {\n\titem.Id += 10\n\tfmt.Println(item)\n}\n\nfunc main() {\n\tlist := []Item{\n\t\t{Id: 1, Name: \"item1\"},\n\t\t{Id: 2, Name: \"item2\"},\n\t\t{Id: 3, Name: \"item3\"},\n\t\t{Id: 4, Name: \"item4\"},\n\t\t{Id: 5, Name: \"item5\"},\n\t}\n\n\texecLoop(list)\n}\n\n// {11 item1}\n// {12 item2}\n// {13 item3}\n// {14 item4}\n// {15 item5}\n```\n\nループ内の処理を並列化する。\n```go\npackage main\n\nimport (\n\t\"fmt\"\n\t\"sync\"\n)\n\ntype Item struct {\n\tId   int\n\tName string\n}\n\nfunc execLoop(list []Item) {\n\tvar wg sync.WaitGroup\n\tfor _, item := range list {\n\t\twg.Add(1)\n\t\tgo func(item2 Item) {\n\t\t\tdefer wg.Done()\n\t\t\tdoSomething(item2)\n\t\t}(item)\n\t}\n\twg.Wait()\n}\n\nfunc doSomething(item Item) {\n\titem.Id += 10\n\tfmt.Println(item)\n}\n\nfunc main() {\n\tlist := []Item{\n\t\t{Id: 1, Name: \"item1\"},\n\t\t{Id: 2, Name: \"item2\"},\n\t\t{Id: 3, Name: \"item3\"},\n\t\t{Id: 4, Name: \"item4\"},\n\t\t{Id: 5, Name: \"item5\"},\n\t}\n\n\texecLoop(list)\n}\n\n// {15 item5}\n// {11 item1}\n// {14 item4}\n// {13 item3}\n// {12 item2}\n```\n\n## sync.Mutex を使う\n```go\npackage main\n\nimport \"fmt\"\n\ntype myClass struct {\n\tAttributeName string\n}\n\nfunc main() {\n\tsourceSlice := make([]myClass, 100)\n\tdestSlice := make([]myClass, 0)\n\n\tfor _, myObj := range sourceSlice {\n\t\tvar tmpObj myClass\n\t\ttmpObj.AttributeName = myObj.AttributeName\n\t\tdestSlice = append(destSlice, tmpObj)\n\t}\n\tfmt.Println(len(destSlice))\n}\n\n// 100\n```\n\nsync.WaitGroup を使う。 ( ダメな例 )\nappend はスレッドセーフではないので件数が減る。\n```go\npackage main\n\nimport (\n\t\"fmt\"\n\t\"sync\"\n)\n\ntype myClass struct {\n\tAttributeName string\n}\n\nfunc main() {\n\tsourceSlice := make([]myClass, 100)\n\tdestSlice := make([]myClass, 0)\n\n\tvar wg sync.WaitGroup\n\tfor _, myObj := range sourceSlice {\n\t\twg.Add(1)\n\t\tgo func(myObj2 myClass) {\n\t\t\tdefer wg.Done()\n\t\t\tvar tmpObj myClass\n\t\t\ttmpObj.AttributeName = myObj2.AttributeName\n\t\t\tdestSlice = append(destSlice, tmpObj)\n\t\t}(myObj)\n\t}\n\twg.Wait()\n\tfmt.Println(len(destSlice))\n}\n\n// 75\n```\n\n`-race` を付けることで競合のチェックができる。\n```bash\n$ go run -race main.go\n\n~~ 省略 ~~\n==================\n97\n```\n\nsync.Mutex を使う。\n```go\npackage main\n\nimport (\n\t\"fmt\"\n\t\"sync\"\n)\n\ntype myClass struct {\n\tAttributeName string\n}\n\nfunc main() {\n\tsourceSlice := make([]myClass, 100)\n\tdestSlice := make([]myClass, 0)\n\n\tvar wg sync.WaitGroup\n\tmu := &sync.Mutex{}\n\tfor _, myObj := range sourceSlice {\n\t\twg.Add(1)\n\t\tgo func(myObj2 myClass) {\n\t\t\tdefer wg.Done()\n\t\t\tvar tmpObj myClass\n\t\t\ttmpObj.AttributeName = myObj2.AttributeName\n\t\t\tmu.Lock()\n\t\t\tdestSlice = append(destSlice, tmpObj)\n\t\t\tmu.Unlock()\n\t\t}(myObj)\n\t}\n\twg.Wait()\n\tfmt.Println(len(destSlice))\n}\n\n// 100\n```\n\n## ポーリング\n`len(q)` は溜まったバッファ数を返す。\n`make` で作るときはバッファ数を 2 以上で作らないと `len(q)` は常に 0 を返す。\n```go\npackage main\n\nimport (\n\t\"fmt\"\n\t\"time\"\n)\n\nfunc main() {\n\tq := make(chan struct{}, 2)\n\n\tgo func() {\n\t\t// 重たい処理\n\t\ttime.Sleep(3 * time.Second)\n\t\tq <- struct{}{}\n\t}()\n\n\tfor {\n\t\tif len(q) > 0 {\n\t\t\tfmt.Println(\"完了\")\n\t\t\tbreak\n\t\t}\n\t\ttime.Sleep(1 * time.Second)\n\t\tfmt.Println(\"実行中\")\n\t}\n}\n\n// 実行中\n// 実行中\n// 実行中\n// 完了\n```\n\n## ワーカー\n`close(q)` されたら `str, ok := <- q` の `ok` が `false` になる。\n```go\npackage main\n\nimport (\n\t\"fmt\"\n\t\"sync\"\n\t\"time\"\n)\n\nfunc printString(wg *sync.WaitGroup, q chan string) {\n\tdefer wg.Done()\n\n\tfor {\n\t\tstr, ok := <-q\n\t\tif !ok {\n\t\t\treturn\n\t\t}\n\n\t\tfmt.Println(str)\n\t\ttime.Sleep(3 * time.Second)\n\t}\n}\n\nfunc main() {\n\tconst workerNum = 3\n\tvar wg sync.WaitGroup\n\tq := make(chan string, 5)\n\n\tfor i := 0; i < workerNum; i++ {\n\t\twg.Add(1)\n\t\tgo printString(&wg, q)\n\t}\n\n\tq <- \"test1\"\n\tq <- \"test2\"\n\tq <- \"test3\"\n\tq <- \"test4\"\n\tq <- \"test5\"\n\tclose(q)\n\twg.Wait()\n}\n\n// test2\n// test1\n// test3\n// test5\n// test4\n```\n"}},"__N_SSG":true}